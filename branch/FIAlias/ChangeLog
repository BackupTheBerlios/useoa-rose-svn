8/2/05 	Version 0.1 	Brian White 
	- Created ChangeLog to keep Beata and I from confusing
	  versions as we share code.  This is not actually the
	  first version of the code-- Beata is responsible for the
	  vast majority of this implementation; I have only added
	  a few methods.
	- The SageIRInterface now partially implements the following
	  interfaces:
		OA::SSA::SSAIRInterface,
		OA::CFG::CFGIRInterfaceDefault,  
		OA::CallGraph::CallGraphIRInterface,
		OA::Alias::AliasIRInterfaceDefault,
		OA::ReachDefs::ReachDefsIRInterface,
		OA::UDDUChains::UDDUChainsIRInterface,
		OA::XAIF::XAIFIRInterface,
		OA::DataFlow::ParamBindingsIRInterface,
		OA::SideEffect::InterSideEffectIRInterfaceDefault,
		OA::SideEffect::SideEffectIRInterface
          Of the above, the following were added:
		OA::SSA::SSAIRInterface,
		OA::DataFlow::ParamBindingsIRInterface,
		OA::SideEffect::InterSideEffectIRInterfaceDefault,
		OA::SideEffect::SideEffectIRInterface
	  Made all inheritance of these interfaces virtual
	  (public OA::CFG::CFGIRInterfaceDefault and 
	  public OA::Alias::AliasIRInterfaceDefault were not previously
	  virtual).  
	- The control flow graph, call graph, and param binding
	  interfaces have been superficially tested within
	  extensions to ROSE 0.8.4c.  This requires wrappers not
	  present here.
	- Renamed files (and changed Makefile accordingly) to be
	  consistent with ROSE naming conventions (as these files
	  will eventually reside in the ROSE tree):
		MemSage2OA.cpp      -> MemSage2OA.C
		MemSage2OA.hpp      -> MemSage2OA.h
		NewSage2OA.cpp      -> Sage2OA.C
		NewSage2OA.hpp      -> Sage2OA.h
		SageOACallGraph.cpp -> SageOACallGraph.C
		SageOACallGraph.hpp -> SageOACallGraph.h
	- Attempted to convert any 'for now's or otherwise
	  seemingly unimplemented methods to call abort().  This
	  makes it clear when running a test what remains to
	  be implemented.
	- Retired MemSageIRTopMemRefIterator in MemSage2OA.h.
	- Changed SageIRProcIterator in SageOACallGraph.h so that
	  it operates on a SgNode rather than being restricted
	  to a SgProject (which isa SgNode).
	- Added the following typedefs/types:
		SageMemRefHandleIterator    (MemSage2OA.h)
		SageSymHandleIterator       (Sage2OA.h)
		SageIRSymIterator	    (Sage2OA.h)
		SageIRFormalParamIterator   (Sage2OA.h)
		SageExprHandleIterator	    (Sage2OA.h)
		SageIRCallsiteParamIterator (Sage2OA.h)
	- Implemented the following methods:
		OA::OA_ptr<OA::IRFormalParamIterator> getFormalParamIterator(OA::SymHandle h);
		OA::OA_ptr<OA::IRCallsiteParamIterator> getCallsiteParams(OA::ExprHandle h);
		bool isRefParam(OA::SymHandle);
		OA::SymHandle getFormalForActual(OA::ProcHandle caller, OA::ExprHandle call,
						 OA::ProcHandle callee, OA::ExprHandle param);
		OA::OA_ptr<OA::ExprTree> getExprTree(OA::ExprHandle h);
		OA::StmtLabel SageIRInterface::getTargetLabel(OA::StmtHandle h, int);
		OA::StmtLabel SageIRInterface::getLabel(OA::StmtHandle h);
		OA::SymHandle SageIRInterface::getSymHandle(OA::LeafHandle h);
	- Changed getSymHandle to use the helper function
	  getFunctionDeclaration which accounts for the fact that
	  the SgFunctionCallExp (i.e., the ExprHandle argument) may
	  be a C++ method.  Notice that getFunctionDeclaration
	  still does not handle the case of a dereferenced function
	  pointer (i.e., SgPointerDerefExp).  In this case, there is
	  potentially more than one function declaration (since
	  control flow may dictate that multiple definitions can
	  reach the same function pointer variable).
	- Changed return type of getDefMemRefs from IRTopMemRefIterator
	  to MemRefHandleIterator.

8/24/05 Version 0.2 	Brian White 
	- Re-implemented getDefMemRefs, getUseMemRefs, getAllMemRefs;
	  all of which use getMemRefIterator.  The real workhorse
	  here is SageIRMemRefIterator.  Passes all examples
	  on the OpenAnalysis Wiki.
	- Allowed NULL ProcHandle to be passed to getProcSymHandle.
	- Added a slew of output methods:
	  void dump(OA::OA_ptr<OA::NamedLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnnamedLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::InvisibleLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnknownLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::Location> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::NamedRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnnamedRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnknownRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::Deref> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::MemRefExpr> memRefExp, std::ostream &os);

8/29/05 Version 0.3 	Brian White
 	- Modified OA::OA_ptr<OA::ExprTree> SageIRInterface::getExprTree
	  to invoke isMemRefNode (defined in MemSage2OA.C) to determine
	  whether a node is a MemRefNode.  Moved isMemRefNode out of
	  a class definition so that it may be used as a general utility
	  function.  Note that isMemRefNode returns true for nodes that
	  are also CallNodes and OpNodes.  i.e., these distinctions are
	  not disjoint.  For now, if a node is a MemRefNode, we create
	  a MemRefNode for it in the ExprTree.  In the future, we may
	  want a node that captures more than one of these designations
	  (e.g., CallMemRefNode and OpMemRefNode).
	- Added ifdef guards (BWHITE_VERSION) that should only be
	  defined by Brian when he's using a local version of OpenAnalysis
	  which includes new MemRefExpr constructors and the following
	  methods:
		isDefUse()
		isUseDef()
		setMemRefType()
	  These should be added to the OpenAnalysis distribution "soon".
	- Added OAConfig.h to the distribution.  I had forgotten to 
	  include this in earlier versions.

8/29/05 Version 0.4 	Brian White	
	- Added the following unimplemented methods to SageIRInterface
	  that have been added to the OpenAnalysis interface:
	OA::OA_ptr<OA::IRSymIterator> getRefSymIterator(OA::ProcHandle h);
	bool isParam(OA::SymHandle);
	OA::OA_ptr<OA::SSA::IRUseDefIterator> getUses(OA::StmtHandle h);
	OA::OA_ptr<OA::SSA::IRUseDefIterator> getDefs(OA::StmtHandle h);
	  They simply ROSE_ABORT();
	- Defined SageIRUseDefIterator
	- Compiled testAll

8/31/05 Version 0.5 	Brian White		
	- Modified OA::Alias::IRStmtType getAliasStmtType(OA::StmtHandle h)
	  to generalize the notion of assignment from SgAssignOp to include
	  SgAndAssignOp, SgDivAssignOp, etc.  These may or may not
	  make sense here (in the context of pointer assignments), but
	  it is safe to include them.  I think some of them will
	  apply in the context of pointer arithmetic. 
	  [Thought better of this and commented it out.]
	  Also modified this method to handle typedefs, as per Beata's
	  comment.
	- Implemented 
	  OA::OA_ptr<OA::Alias::PtrAssignPairStmtIterator>
                getPtrAssignStmtPairIterator(OA::StmtHandle stmt)
	  and
	  class SgPtrAssignPairStmtIterator
	  The latter is the workhorse here.
	- Modified findAllMemRefsAndMemRefExprs to return a MemRefExp
	  for SgThisExp.  Also modified toString(SymHandle) to expect
	  a SgThisExp.
	- Changed constructor of SageIRInterface to take a SgNode*
	  rather than a SgProject*.  Note that a SgProject isa SgNode.
	- Added new method needed for FIAlias:
	  OA_ptr<ParamBindPtrAssignIterator>
	  getParamBindPtrAssignIterator(ExprHandle callsite);	
          and implemented the following class which does all of the work:
	  SgParamBindPtrAssignIterator
	- Implemented the following methods to support FIAlias:
	  OA::SymHandle getFormalSym(OA::ProcHandle, int);
	  OA::OA_ptr<OA::MemRefExpr> getCallMemRefExpr(OA::CallHandle h);
	  OA::ProcHandle getProcHandle(OA::SymHandle sym);
	- Changed SageIRCallsiteIterator::current() to return a CallHandle
	  instead of an ExprHandle.
	- Changed getFormalParamIterator, getFormalForActual,
	  and findAllMemRefsAndMemRefExprs to
	  return a symbol handle representing a SgClassSymbol whenever
	  we encounter a SgThisExp.  This includes both this->blah
	  expressions and the first (pseudo-)actual of a method 
	  invocation.  This pseudo-actual reprsents the class object
	  upon which the method is invoked.
	- Moved utility function isMemRefNode into SageIRInterface
	  as a protected method.  Thus, made the following friends
	  so they could access it:
	  friend class SgParamBindPtrAssignIterator;
	  friend class ExprTreeTraversal;
	- Modified SageIRInterface::getCallsiteParams to return
	  the lhs of an arrow/dot expression as the first actual
	  parameter of a method invocation.  Previously, the
	  arrow/dot expression was being returned.  Notice that 
	  if the expression is a dot expression whose lhs is
	  a SgPointerDerefExp, then it is actually a normalized
	  arrow exp.  These get treated differently with respect
	  to MemRefHandles and MemRefExprs.  In this case, we
	  really want the operand of the SgPointerDerefExp.
	- Added utility method getEnclosingMethod(SgNode *node)
	  to return the method in which node occurs (else NULL)
	- isRefParam now only returns true if the parameter is
	  a reference paramter.  Added isPointerVar to
	  return true if the variable is a pointer.
	- Added isReferenceExpr to return true if expr represents
	  a reference variable.  Note it is _not sufficient to
	  extract the symbol from the expr and invoke isReferenceVar
	  since we do not represent everything will full accuracy.
	  In particular isReferenceExpr(a->b) is a question of a->b
	  not a.  However, currently we only have info about a in
	  the MemRefExpr, not b.
	- Fixed SageIRInterface::getAliasStmtType(OA::StmtHandle h)
	  to properly handle SgVariableDeclarations.
	- Modified getStmtIterator(procHandle) to return the 
	  constructor initialization list if procHandle is a constructor.
	- Changed SageIRInterface::getLoopIncrement so that it no longer
	  creates a SgExprStatement for the loop increment (expression).
	  Instead, it "coerces" the SgExpression that is the loop
	  increment into the OA::StmtHandle return type.

10/21/05 UseOA-ROSE-v0.6	Brian White
	- Restructured directory.
	- Added options to OATest.C:
		--debug prints out debugging info
		--printRose uses the output methods
	          ROSE/test/roseTests/programAnalysisTests/MemRefExprTest.C
                  which don't print handles, pointers, etc.
	          The default uses the output method, which also
	          avoids handles (Michelle's change).  The original
	          code used dump.  Make printRose go away after I
	          get it checked in once.
	- Added MemRefExprTestInput.C to TestCases.  This reflects
	  all examples from the Wiki and was taken from
	  ROSE/test/roseTests/programAnalysisTests.
	- Incorporated Michelle's changes to testAll, which is now OATest.
        - Results of OATest --oa-MemRefExpr TestCases/MemRefExprTestInput.C
	  are in TestResults/MemRefExprTestInput.C.out
	- Problem:  the link line is very fragile since both OpenAnalysis
	  and SageOA routines are included in Rose.  I was unsuccessful
	  in making the OAWrap dir a library which OATest links against.
	  For now, I'm brute forcing by including the .o's on the 
	  link line.  Fix this.

10/26/05 UseOA-ROSE-v0.6.0b	Brian White	
	- Fixed some problems on the link line that we preventing
	  us from resolving symbols from the OpenAnalysis and SageOA
	  libraries.  Notice that your installation of ROSE may
	  defined (weak) symbols that conflict with those in these
	  two libraries.  By putting them first on the link line,
	  those libraries should override the ROSE library.

10/26/05 UseOA-ROSE-v0.6.0c	Brian White	
	- Incorporated Michelle's changing of order of Sage2OA lib and
	  OpenAnalysis in Makefile.
	- Commented out dump in favor of output in OATest MemRefExpr
	  test case, so that we don't get handles.
	- Removed #ifdef BWHITE_VERSION
	- More messing around with the makefile
	- Fixed a.b to return only one MemRefExpr:
	  NamedRef(USE, SymHandle(b), partial) i.e., corresponding
	  to a.b.
	  Notice that sta[a][b][c].d also only returns only one
	  MemRefExpr (NamedRef(USE, SymHandle(sta), partial))

11/11/05 UseOA-ROSE-???		Brian White
	- Modified SageIRProcIterator so that it returns
	  constructors.
	- Changed representation of the formal corresponding to
	  'this' from a SgFunctionDefinition (which may not
	  be accessible) to a SgFunctionParameterList.  This
	  is non-sensical, but should only be used to form
	  alias sets.  Since we only care about the formal
	  insofar as which actuals it is bound to, it shouldn't
	  make a difference that we chose a silly representation.
	- Added implicit 'this' actual arg as an argument to new
          in SageIRInterface::getCallsiteParams.
	- Added param binding for 'this' arg to new in 
	  in SgParamBindPtrAssignIterator::create.
	- Explicitly model references to this.  i.e., we ignore
	  SgThisExp in SageIRMemRefIterator::findAllMemRefsAndMemRefExprs.
	  If a SgVarRefExpr or SgInitializedName is a member m of a class,
	  then SageIRMemRefIterator::findAllMemRefsAndMemRefExprs 
	  explicitly creates an MRE for this->m, regardless of whether
	  or not the frontend (i.e., ROSE) has explicitly mentioned the this.
	- Updated getCallMemRefExpr to handle new expressions (as a
	  call handle).
	- Updated getCallMemRefExpr so that it returns NamedRefs
	  for any method/function that can be resolved (including
	  constructor invocations) and returns FieldAccess for
	  virtual methods.  This is accomplished by explicitly
	  creating NamedRefs for functions, since the general
	  getMemRef routines do not consider function calls to 
	  be uses of program state and hence worthy of an MRE; and
	  by use of the general routines in all other cases. 
	  See next comment.
	- Changed getChildrenWithMemRefs and findAllMemRefsAndMemRefExprs 
	  to recognize SgConstructorInitializers so that we handle
	  invocations of new (i.e., of a constructor) as we handle
	  method invocations.  i.e., we create an MRE for them.
 	- Implemented vtable opt:
	       - Updated findAllMemRefsAndMemRefExprs to return
	         (*(*a).FieldHandle(0)).method for a virtual
	         call instead of (*a).method.
	       - Returned implicit ptr assign pairs of form:
		 < (*a).FieldHandle(0), &A > 
                 from createImplicitPtrAssignForMethods
	         where A is a's class.
               - Returned implicit ptr assigns of from:
		 < a.method, A::method >
		 from createImplicitVTablePtrAssignFromDefinition,
                 where A is a's class, a.method is a string-based
	         FieldAccess and A::method is a NamedRef.
	- Changed OATest to use CmdOptions, so we are less/not
	  dependent on order of command line options.
	- Added regressMemRefExpr.script, a knock-off of 
	  genMemRefExprOut.script.  Simply run it without args.
	  If everything goes well it should generate no output.
	  If there are differences between current and expected
	  results, they will be returned.
	- Passed regressMemRefExpr.script.  The following changed
	  from the last version and were deemed correct behavior.
	  All changes occurred in /MemRefExprTestInput.C:
	       - ignoreStructPtr =((struct myStruct *)(malloc(12))); 
	         The StmtHandle for malloc now includes the cast
	         expression.
	       - *hi -> hello() = ignoreInt;
                 Previously, hi->hello was represented as an inaccurate
	         dereference of hi:
		 Deref(
        		mAddressOf: 0
        		mFullAccuracy: 0
		        mMemRefType: USE
		        mMRE: 
		        NamedRef(
		                mAddressOf: 0
		                mFullAccuracy: 1
		                mMemRefType: USE
		                mSymHandle: SymHandle(hi)       )
		        mNumDeref: 1)
		  However, we can actually say with full accuracy
	          the method that is invoked.  So instead, we 
	          return:
		  NamedRef(
		        mAddressOf: 0
		        mFullAccuracy: 1
		        mMemRefType: USE
		        mSymHandle: SymHandle(hello))
                - Added invocation of virtual method call:
		  *hi -> goodbye() = ignoreInt;
		  which results in a FieldAccess of Deref(hi).

11/18/05 UseOA-ROSE-???		Brian White		
	- Changed lookThroughCastExpAndAssignInitializer(node) so 
	  that it does not "look past" a cast expression if it
	  decorates a malloc.  Consider doing this for all mem
	  expressions?  And including casts in those expresions
	  as is now done for malloc?
	- Added --oa-FIAlias option to OATest.
	- Added regression tests for alias:
		genAliasTestsOut.script 
	        regressAliasTestsOut.script
	  Notice that an exit in each of these scripts
	  demarcate those tests that have passed.
	  Current tests passed:  None!
	  Current tests cause aborts/seg faults/etc:
		HindEtAlIBM95Fig4.C
		HindEtAlISSTA00Fig1.C
		LattnerEtAl03Fig1.C
		PandeEtAlRutgers05.C
		refClass.C
		RinardEtAlPLDI96Fig4.C
		RyderEtAlFig14.c
		RyderEtAlFig15.c
		YongEtAlPLDI99.c

11/21/05 UseOA-ROSE-???		Brian White
	- All alias tests compile/run except:
		LattnerEtAl03Fig1.C
	  which uses a function pointer.  This causes
	  an assertion to fail in SageOA because we can not
	  retrieve the function declaration of the function call
	  expression.  Suggested fix:  change FIAlias so that
	  it first resolves function pointers and then invokes
	  getParamBindPtrAssignIterator, which is where fault occurs.
	- Changed creation of nodeArray for persistent handles
	  so that it manually traverses the AST.  Some of the nodes
	  are not visited by the ROSE traversal mechanisms and so
	  were not getting numbered.  This fixed many of the 
	  above problems.
	- Still haven't tested the alias results for correctness.

11/21/05 UseOA-ROSE svn tag FIAlias r15		Michelle Strout
	- Marked output files in regressMemRefExpr.script that have 
	  been checked.  Only TestCases/MemRefExprTests/MemRefExprTestInput.C
	  still has issues.
	- Renamed target directory for FIAlias results to 
	  TestsResults/FIAlias since other alias analysis algorithms
	  will have different results.
