8/2/05 	Version 0.1 	Brian White 
	- Created ChangeLog to keep Beata and I from confusing
	  versions as we share code.  This is not actually the
	  first version of the code-- Beata is responsible for the
	  vast majority of this implementation; I have only added
	  a few methods.
	- The SageIRInterface now partially implements the following
	  interfaces:
		OA::SSA::SSAIRInterface,
		OA::CFG::CFGIRInterfaceDefault,  
		OA::CallGraph::CallGraphIRInterface,
		OA::Alias::AliasIRInterfaceDefault,
		OA::ReachDefs::ReachDefsIRInterface,
		OA::UDDUChains::UDDUChainsIRInterface,
		OA::XAIF::XAIFIRInterface,
		OA::DataFlow::ParamBindingsIRInterface,
		OA::SideEffect::InterSideEffectIRInterfaceDefault,
		OA::SideEffect::SideEffectIRInterface
          Of the above, the following were added:
		OA::SSA::SSAIRInterface,		OA::DataFlow::ParamBindingsIRInterface,
		OA::SideEffect::InterSideEffectIRInterfaceDefault,
		OA::SideEffect::SideEffectIRInterface
	  Made all inheritance of these interfaces virtual
	  (public OA::CFG::CFGIRInterfaceDefault and 
	  public OA::Alias::AliasIRInterfaceDefault were not previously
	  virtual).  
	- The control flow graph, call graph, and param binding
	  interfaces have been superficially tested within
	  extensions to ROSE 0.8.4c.  This requires wrappers not
	  present here.
	- Renamed files (and changed Makefile accordingly) to be
	  consistent with ROSE naming conventions (as these files
	  will eventually reside in the ROSE tree):
		MemSage2OA.cpp      -> MemSage2OA.C
		MemSage2OA.hpp      -> MemSage2OA.h
		NewSage2OA.cpp      -> Sage2OA.C
		NewSage2OA.hpp      -> Sage2OA.h
		SageOACallGraph.cpp -> SageOACallGraph.C
		SageOACallGraph.hpp -> SageOACallGraph.h
	- Attempted to convert any 'for now's or otherwise
	  seemingly unimplemented methods to call abort().  This
	  makes it clear when running a test what remains to
	  be implemented.
	- Retired MemSageIRTopMemRefIterator in MemSage2OA.h.
	- Changed SageIRProcIterator in SageOACallGraph.h so that
	  it operates on a SgNode rather than being restricted
	  to a SgProject (which isa SgNode).
	- Added the following typedefs/types:
		SageMemRefHandleIterator    (MemSage2OA.h)
		SageSymHandleIterator       (Sage2OA.h)
		SageIRSymIterator	    (Sage2OA.h)
		SageIRFormalParamIterator   (Sage2OA.h)
		SageExprHandleIterator	    (Sage2OA.h)
		SageIRCallsiteParamIterator (Sage2OA.h)
	- Implemented the following methods:
		OA::OA_ptr<OA::IRFormalParamIterator> getFormalParamIterator(OA::SymHandle h);
		OA::OA_ptr<OA::IRCallsiteParamIterator> getCallsiteParams(OA::ExprHandle h);
		bool isRefParam(OA::SymHandle);
		OA::SymHandle getFormalForActual(OA::ProcHandle caller, OA::ExprHandle call,
						 OA::ProcHandle callee, OA::ExprHandle param);
		OA::OA_ptr<OA::ExprTree> getExprTree(OA::ExprHandle h);
		OA::StmtLabel SageIRInterface::getTargetLabel(OA::StmtHandle h, int);
		OA::StmtLabel SageIRInterface::getLabel(OA::StmtHandle h);
		OA::SymHandle SageIRInterface::getSymHandle(OA::LeafHandle h);
	- Changed getSymHandle to use the helper function
	  getFunctionDeclaration which accounts for the fact that
	  the SgFunctionCallExp (i.e., the ExprHandle argument) may
	  be a C++ method.  Notice that getFunctionDeclaration
	  still does not handle the case of a dereferenced function
	  pointer (i.e., SgPointerDerefExp).  In this case, there is
	  potentially more than one function declaration (since
	  control flow may dictate that multiple definitions can
	  reach the same function pointer variable).
	- Changed return type of getDefMemRefs from IRTopMemRefIterator
	  to MemRefHandleIterator.

8/24/05 Version 0.2 	Brian White 
	- Re-implemented getDefMemRefs, getUseMemRefs, getAllMemRefs;
	  all of which use getMemRefIterator.  The real workhorse
	  here is SageIRMemRefIterator.  Passes all examples
	  on the OpenAnalysis Wiki.
	- Allowed NULL ProcHandle to be passed to getProcSymHandle.
	- Added a slew of output methods:
	  void dump(OA::OA_ptr<OA::NamedLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnnamedLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::InvisibleLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnknownLoc> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::Location> loc, std::ostream& os);
	  void dump(OA::OA_ptr<OA::NamedRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnnamedRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::UnknownRef> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::Deref> memRefExp, std::ostream& os);
	  void dump(OA::OA_ptr<OA::MemRefExpr> memRefExp, std::ostream &os);

8/29/05 Version 0.3 	Brian White
 	- Modified OA::OA_ptr<OA::ExprTree> SageIRInterface::getExprTree
	  to invoke isMemRefNode (defined in MemSage2OA.C) to determine
	  whether a node is a MemRefNode.  Moved isMemRefNode out of
	  a class definition so that it may be used as a general utility
	  function.  Note that isMemRefNode returns true for nodes that
	  are also CallNodes and OpNodes.  i.e., these distinctions are
	  not disjoint.  For now, if a node is a MemRefNode, we create
	  a MemRefNode for it in the ExprTree.  In the future, we may
	  want a node that captures more than one of these designations
	  (e.g., CallMemRefNode and OpMemRefNode).
	- Added ifdef guards (BWHITE_VERSION) that should only be
	  defined by Brian when he's using a local version of OpenAnalysis
	  which includes new MemRefExpr constructors and the following
	  methods:
		isDefUse()
		isUseDef()
		setMemRefType()
	  These should be added to the OpenAnalysis distribution "soon".
	- Added OAConfig.h to the distribution.  I had forgotten to 
	  include this in earlier versions.

8/29/05 Version 0.4 	Brian White	
	- Added the following unimplemented methods to SageIRInterface
	  that have been added to the OpenAnalysis interface:
	OA::OA_ptr<OA::IRSymIterator> getRefSymIterator(OA::ProcHandle h);
	bool isParam(OA::SymHandle);
	OA::OA_ptr<OA::SSA::IRUseDefIterator> getUses(OA::StmtHandle h);
	OA::OA_ptr<OA::SSA::IRUseDefIterator> getDefs(OA::StmtHandle h);
	  They simply ROSE_ABORT();
	- Defined SageIRUseDefIterator
	- Compiled testAll

8/31/05 Version 0.5 	Brian White		
	- Modified OA::Alias::IRStmtType getAliasStmtType(OA::StmtHandle h)
	  to generalize the notion of assignment from SgAssignOp to include
	  SgAndAssignOp, SgDivAssignOp, etc.  These may or may not
	  make sense here (in the context of pointer assignments), but
	  it is safe to include them.  I think some of them will
	  apply in the context of pointer arithmetic. 
	  [Thought better of this and commented it out.]
	  Also modified this method to handle typedefs, as per Beata's
	  comment.
	- Implemented 
	  OA::OA_ptr<OA::Alias::PtrAssignPairStmtIterator>
                getPtrAssignStmtPairIterator(OA::StmtHandle stmt)
	  and
	  class SgPtrAssignPairStmtIterator
	  The latter is the workhorse here.
	- Modified findAllMemRefsAndMemRefExprs to return a MemRefExp
	  for SgThisExp.  Also modified toString(SymHandle) to expect
	  a SgThisExp.
	- Changed constructor of SageIRInterface to take a SgNode*
	  rather than a SgProject*.  Note that a SgProject isa SgNode.
	- Added new method needed for FIAlias:
	  OA_ptr<ParamBindPtrAssignIterator>
	  getParamBindPtrAssignIterator(ExprHandle callsite);	
          and implemented the following class which does all of the work:
	  SgParamBindPtrAssignIterator
	- Implemented the following methods to support FIAlias:
	  OA::SymHandle getFormalSym(OA::ProcHandle, int);
	  OA::OA_ptr<OA::MemRefExpr> getCallMemRefExpr(OA::CallHandle h);
	  OA::ProcHandle getProcHandle(OA::SymHandle sym);
	- Changed SageIRCallsiteIterator::current() to return a CallHandle
	  instead of an ExprHandle.
	- Changed getFormalParamIterator, getFormalForActual,
	  and findAllMemRefsAndMemRefExprs to
	  return a symbol handle representing a SgClassSymbol whenever
	  we encounter a SgThisExp.  This includes both this->blah
	  expressions and the first (pseudo-)actual of a method 
	  invocation.  This pseudo-actual reprsents the class object
	  upon which the method is invoked.
	- Moved utility function isMemRefNode into SageIRInterface
	  as a protected method.  Thus, made the following friends
	  so they could access it:
	  friend class SgParamBindPtrAssignIterator;
	  friend class ExprTreeTraversal;
	- Modified SageIRInterface::getCallsiteParams to return
	  the lhs of an arrow/dot expression as the first actual
	  parameter of a method invocation.  Previously, the
	  arrow/dot expression was being returned.  Notice that 
	  if the expression is a dot expression whose lhs is
	  a SgPointerDerefExp, then it is actually a normalized
	  arrow exp.  These get treated differently with respect
	  to MemRefHandles and MemRefExprs.  In this case, we
	  really want the operand of the SgPointerDerefExp.
	- Added utility method getEnclosingMethod(SgNode *node)
	  to return the method in which node occurs (else NULL)
	- isRefParam now only returns true if the parameter is
	  a reference paramter.  Added isPointerVar to
	  return true if the variable is a pointer.
	- Added isReferenceExpr to return true if expr represents
	  a reference variable.  Note it is _not sufficient to
	  extract the symbol from the expr and invoke isReferenceVar
	  since we do not represent everything will full accuracy.
	  In particular isReferenceExpr(a->b) is a question of a->b
	  not a.  However, currently we only have info about a in
	  the MemRefExpr, not b.
	- Fixed SageIRInterface::getAliasStmtType(OA::StmtHandle h)
	  to properly handle SgVariableDeclarations.
	- Modified getStmtIterator(procHandle) to return the 
	  constructor initialization list if procHandle is a constructor.
	- Changed SageIRInterface::getLoopIncrement so that it no longer
	  creates a SgExprStatement for the loop increment (expression).
	  Instead, it "coerces" the SgExpression that is the loop
	  increment into the OA::StmtHandle return type.

10/21/05 UseOA-ROSE-v0.6	Brian White
	- Restructured directory.
	- Added options to OATest.C:
		--debug prints out debugging info
		--printRose uses the output methods
	          ROSE/test/roseTests/programAnalysisTests/MemRefExprTest.C
                  which don't print handles, pointers, etc.
	          The default uses the output method, which also
	          avoids handles (Michelle's change).  The original
	          code used dump.  Make printRose go away after I
	          get it checked in once.
	- Added MemRefExprTestInput.C to TestCases.  This reflects
	  all examples from the Wiki and was taken from
	  ROSE/test/roseTests/programAnalysisTests.
	- Incorporated Michelle's changes to testAll, which is now OATest.
        - Results of OATest --oa-MemRefExpr TestCases/MemRefExprTestInput.C
	  are in TestResults/MemRefExprTestInput.C.out
	- Problem:  the link line is very fragile since both OpenAnalysis
	  and SageOA routines are included in Rose.  I was unsuccessful
	  in making the OAWrap dir a library which OATest links against.
	  For now, I'm brute forcing by including the .o's on the 
	  link line.  Fix this.

10/26/05 UseOA-ROSE-v0.6.0b	Brian White	
	- Fixed some problems on the link line that we preventing
	  us from resolving symbols from the OpenAnalysis and SageOA
	  libraries.  Notice that your installation of ROSE may
	  defined (weak) symbols that conflict with those in these
	  two libraries.  By putting them first on the link line,
	  those libraries should override the ROSE library.

10/26/05 UseOA-ROSE-v0.6.0c	Brian White	
	- Incorporated Michelle's changing of order of Sage2OA lib and
	  OpenAnalysis in Makefile.
	- Commented out dump in favor of output in OATest MemRefExpr
	  test case, so that we don't get handles.
	- Removed #ifdef BWHITE_VERSION
	- More messing around with the makefile
	- Fixed a.b to return only one MemRefExpr:
	  NamedRef(USE, SymHandle(b), partial) i.e., corresponding
	  to a.b.
	  Notice that sta[a][b][c].d also only returns only one
	  MemRefExpr (NamedRef(USE, SymHandle(sta), partial))

11/11/05 UseOA-ROSE-???		Brian White
	- Modified SageIRProcIterator so that it returns
	  constructors.
	- Changed representation of the formal corresponding to
	  'this' from a SgFunctionDefinition (which may not
	  be accessible) to a SgFunctionParameterList.  This
	  is non-sensical, but should only be used to form
	  alias sets.  Since we only care about the formal
	  insofar as which actuals it is bound to, it shouldn't
	  make a difference that we chose a silly representation.
	- Added implicit 'this' actual arg as an argument to new
          in SageIRInterface::getCallsiteParams.
	- Added param binding for 'this' arg to new in 
	  in SgParamBindPtrAssignIterator::create.
	- Explicitly model references to this.  i.e., we ignore
	  SgThisExp in SageIRMemRefIterator::findAllMemRefsAndMemRefExprs.
	  If a SgVarRefExpr or SgInitializedName is a member m of a class,
	  then SageIRMemRefIterator::findAllMemRefsAndMemRefExprs 
	  explicitly creates an MRE for this->m, regardless of whether
	  or not the frontend (i.e., ROSE) has explicitly mentioned the this.
	- Updated getCallMemRefExpr to handle new expressions (as a
	  call handle).
	- Updated getCallMemRefExpr so that it returns NamedRefs
	  for any method/function that can be resolved (including
	  constructor invocations) and returns FieldAccess for
	  virtual methods.  This is accomplished by explicitly
	  creating NamedRefs for functions, since the general
	  getMemRef routines do not consider function calls to 
	  be uses of program state and hence worthy of an MRE; and
	  by use of the general routines in all other cases. 
	  See next comment.
	- Changed getChildrenWithMemRefs and findAllMemRefsAndMemRefExprs 
	  to recognize SgConstructorInitializers so that we handle
	  invocations of new (i.e., of a constructor) as we handle
	  method invocations.  i.e., we create an MRE for them.
 	- Implemented vtable opt:
	       - Updated findAllMemRefsAndMemRefExprs to return
	         (*(*a).FieldHandle(0)).method for a virtual
	         call instead of (*a).method.
	       - Returned implicit ptr assign pairs of form:
		 < (*a).FieldHandle(0), &A > 
                 from createImplicitPtrAssignForMethods
	         where A is a's class.
               - Returned implicit ptr assigns of from:
		 < a.method, A::method >
		 from createImplicitVTablePtrAssignFromDefinition,
                 where A is a's class, a.method is a string-based
	         FieldAccess and A::method is a NamedRef.
	- Changed OATest to use CmdOptions, so we are less/not
	  dependent on order of command line options.
	- Added regressMemRefExpr.script, a knock-off of 
	  genMemRefExprOut.script.  Simply run it without args.
	  If everything goes well it should generate no output.
	  If there are differences between current and expected
	  results, they will be returned.
	- Passed regressMemRefExpr.script.  The following changed
	  from the last version and were deemed correct behavior.
	  All changes occurred in /MemRefExprTestInput.C:
	       - ignoreStructPtr =((struct myStruct *)(malloc(12))); 
	         The StmtHandle for malloc now includes the cast
	         expression.
	       - *hi -> hello() = ignoreInt;
                 Previously, hi->hello was represented as an inaccurate
	         dereference of hi:
		 Deref(
        		mAddressOf: 0
        		mFullAccuracy: 0
		        mMemRefType: USE
		        mMRE: 
		        NamedRef(
		                mAddressOf: 0
		                mFullAccuracy: 1
		                mMemRefType: USE
		                mSymHandle: SymHandle(hi)       )
		        mNumDeref: 1)
		  However, we can actually say with full accuracy
	          the method that is invoked.  So instead, we 
	          return:
		  NamedRef(
		        mAddressOf: 0
		        mFullAccuracy: 1
		        mMemRefType: USE
		        mSymHandle: SymHandle(hello))
                - Added invocation of virtual method call:
		  *hi -> goodbye() = ignoreInt;
		  which results in a FieldAccess of Deref(hi).

11/18/05 UseOA-ROSE-???		Brian White		
	- Changed lookThroughCastExpAndAssignInitializer(node) so 
	  that it does not "look past" a cast expression if it
	  decorates a malloc.  Consider doing this for all mem
	  expressions?  And including casts in those expresions
	  as is now done for malloc?
	- Added --oa-FIAlias option to OATest.
	- Added regression tests for alias:
		genAliasTestsOut.script 
	        regressAliasTestsOut.script
	  Notice that an exit in each of these scripts
	  demarcate those tests that have passed.
	  Current tests passed:  None!
	  Current tests cause aborts/seg faults/etc:
		HindEtAlIBM95Fig4.C
		HindEtAlISSTA00Fig1.C
		LattnerEtAl03Fig1.C
		PandeEtAlRutgers05.C
		refClass.C
		RinardEtAlPLDI96Fig4.C
		RyderEtAlFig14.c
		RyderEtAlFig15.c
		YongEtAlPLDI99.c

11/21/05 UseOA-ROSE-???		Brian White
	- All alias tests compile/run except:
		LattnerEtAl03Fig1.C
	  which uses a function pointer.  This causes
	  an assertion to fail in SageOA because we can not
	  retrieve the function declaration of the function call
	  expression.  Suggested fix:  change FIAlias so that
	  it first resolves function pointers and then invokes
	  getParamBindPtrAssignIterator, which is where fault occurs.
	- Changed creation of nodeArray for persistent handles
	  so that it manually traverses the AST.  Some of the nodes
	  are not visited by the ROSE traversal mechanisms and so
	  were not getting numbered.  This fixed many of the 
	  above problems.
	- Still haven't tested the alias results for correctness.

11/21/05 UseOA-ROSE svn tag FIAlias r15		Michelle Strout
	- Marked output files in regressMemRefExpr.script that have 
	  been checked.  Only TestCases/MemRefExprTests/MemRefExprTestInput.C
	  still has issues.
	- Renamed target directory for FIAlias results to 
	  TestsResults/FIAlias since other alias analysis algorithms
	  will have different results.

11/22/05 UseOA-ROSE svn tag FIAlias r16		Brian White
	- Fixed problem mentioned above in
	     11/21/05 UseOA-ROSE-???		Brian White
          with LattnerEtAl03Fig1.C
	  getParamBindPtrAssignIterator no longer requires a 
	  SgFunctionDeclaration, which may not exist in general and
	  does not exist for a function pointer.  Instead, we
	  query the type of the function pointer/function declaration
	  to get the types of the formals.
	- Now any RefOp of a partially accurate MRE is itself partially
	  accurate.  This should be intuitive, but Michelle says:
                I think that a Deref to a NamedRef that has partial 
	        accuracy should also have partial accuracy.  Why?  
	        Because the partial accuracy indicates that the 
	        whole MemRefExpr (rooted at the Deref) has partial accuracy.
        - Changed regressMemRefExpr.script to reflect my belief that
	  all MemRefExpr tests pass.  Have _not_ updated regression
	  results, but will wait for Michelle to sign off.  There are 5
	  differences, all related to the second bullet above.

11/28/05 UseOA-ROSE svn tag FIAlias r18 	Brian White
	- Changed getCallMemRefExpr to recognize invocations thru
	  function pointers.
	- All FIAlias tests compile w/o seg fault, assertion failures, etc.
	- May have undone Michelle's change (r17) of param type of 
	  getParamBindPtrAssignIterator.  The latest version of OpenAnalysis
	  does not seem to be compatible with an ExprHandle argument.
	- The following (additional) FIAlias tests passed.  Their
	  results were added to TestResults/FIAlias:
	  - funCall.c
	- Michelle has previously verified the following tests which 
	  I've added to TestResults/FIAlias:
	  - alias1.c
	  - alias2.c
	  - alias3.c
	  - alias4.c

11/28/05 UseOA-ROSE svn tag FIAlias r19 	Brian White
	- Added an option to SageIRProcIterator to exclude input files.
	  This should only be used for testing.  It allows us to ignore
	  output generated by procedures defined in header files, 
	  such as stdlib.h.
	- Added handling of comma expression in findAllMemRefsAndMemRefExprs
	  and createPtrAssignPairsFromAssignment.
	- Changed handling of pointer arithmetic MRE such that
	  (base + offset) is treated as an array operation if
	  base is a pointer and offset is an integer.
	- The following (additional) FIAlias tests passed.  Their
	  results were added to TestResults/FIAlias:
	  - utke.c
	  - OAWikiEx.c
	  - comma.c	
	  - constQualified.c

11/29/05 UseOA-ROSE svn tag FIAlias r20 	Brian White
	- Changed toString to output this::className::enclosingMethod
	  for a SgFunctionParameterList, which we use to 
	  represent the 'this' pointer.
	- Changed toString to output 'method:' before a method symbol.
	  I was getting confused when I saw 'B' as in 'class B'.
	  It turns out this was not a symbol representing the class
	  (which we shouldn't see), but a symbol representing a
	  constructor (invocation).
	- Changed handling of FieldAccess in findAllMemRefsAndMemRefExprs.
	  In particular, we no longer demand that a method be virtual
	  in order to create a FieldAccess:
		// NB:  We no longer check that the function is virtual.  
		//      Even if it is not virtual, there may be some ambiguity
		//      in which (class') method is invoked.  For example:
		//      B *b;
		//      if ( cond )
		//         b = new B;
		//      else
		//         b = new C;
		//      b->foo();
		//      where both B and C implement foo.
	- NumberTraversal now nows SgCtorInitializerLists.
	- Fixed a mem leak in SageIRMemRefIterator::create.
	  At some point, do a more thorough job of checking other
	  valgrind warnings.
	- Fixed an obscure bug that was occurring when debug was
	  enabled in ManagerFIAlias and we were using persistent handles.
	  A SgMemberFunctionDeclaration's SgCtorIntializerList
	  may be NULL.  However certain methods, such as get_ctors(),
	  force it into existence.  Therefore, we must invoke get_ctors()
	  during the numbering traversal to force it into existence
	  so that when we later see it, it has been numbered.  Otherwise,
	  we will get an assertion failure in getNodeNumber when
	  using persistent handles because the (newly-created) SgNode
	  was not numbered (since it did not exist at the time of numbering).

11/30/05 UseOA-ROSE svn tag FIAlias r21 	Brian White
	- Notes on ManagerFIAlias output:
	  - If X is a subset of Y, X and Y are union'ed.
	  - The default (i.e., unless VTABLE_OPT is defined)
	    is to use the non-vtable optimization.  
	  - It creates a DEF mre for each formal, regardless of
	    its type.  DEF because it is bound to the actual.
	  - AddressOf MREs do not show up in the list of MREs.
	    These include (new D), etc.
	- Added a method to create an UnnamedLoc from a StmtHandle:
	  OA::OA_ptr<OA::Location::Location> 
          SageIRInterface::getLocation(OA::ProcHandle p, OA::StmtHandle s);
	  At the moment, it conservatively sets the isLocal flag of
	  the location to true.   
	  // But allocated memory is inherently non-local.  It seems that
	  // it should be the job of alias analysis to determine this.
	  // e.g.,
	  // int *global;             
	  // ...
	  // void func() {
	  //   int *local = new int;    // at this point, new int is local.
	  //   global = local;          // it just became globally accessible.
	  // }

11/30/05 UseOA-ROSE svn tag FIAlias r22 	Michelle Strout
	- fixed ManagerFIAlias in OpenAnalysis so that it creates a fixed
   	  location for UnnamedRefs.  Creates non local UnnamedLocs.
	- deleted getLocation(ProcHandle,StmtHandle) from Sage2OA because
  	  it won't be needed due to the above change
	- diffArrays.c: there are some problems with the MemRefExprs that 
  	  are created for this program
    		- p = &a[i], even though a is accessed like an array, 
		  it is still a pointer, the NamedRef access to a here 
		  should be fully accurate
    		- same goes for p=&b[j] and x=*(q+3) for b and q.
    		- now for x=*(q+3), there should be a fully accurate named ref
      		  for x and q.  There should also be a Deref partial to q.  If
      	 	  we were using IdxAccess then it would be an 
      		  IdxAccess(3, Deref(full, NamedRef(q) ) )

12/02/05 UseOA-ROSE svn tag FIAlias r23 	Brian White
	- Updated MemRefExprTestInput.C to include Michelle's new
	  example from the Wiki involving the pointer r accessed as
	  an array.
	- Also added:
		hiClass &hiRef = *hi;	
		*(hiRef.hello()) = ignoreInt;
	- I believe MemRefExprTestInput.C.out.latest is correct.
	  It contains the following diffs wrt MemRefExprTestInput.C.out
	  1.  Michelle's r[x] = ignoreInt example.
	  2.  The two above new statements.
	  3.  SubsetRefs of inaccurate MREs are themselves inaccurate:
		*(sta[3][4][2].bPtr) = ignoreInt;
		*hello() = ignoreInt;
		*hi->hello() = ignoreInt;
		*hi->goodbye() = ignoreInt;
	  4.  *hi->hello is represented by a FieldAccess, not a 
	      NamedRef(SymHandle(hello))
	  5.  Handling of *(r + (int)*q) = ignoreInt:
		- (r + (int)*q) is an inaccurate NamedRef(r),
	          not an UnknownRef
	        - *(r + (int)*q) is a Deref of that inaccurate NamedRef(r),
	          not a Deref(UnknownRef)
	- Added flag passed to findAllMemRefsAndMemRefExprs to indicate
	  that we should not apply the reference conversion rules.
	  At a dot expression, we detect that the lhs is a reference
	  and treat it as an arrow, i.e., deref the lhs.  Changed my
	  mind, handle the reference at the conversion not at the dot.

12/08/05 UseOA-ROSE svn tag FIAlias r24 	Brian White
	- Reversed yet again the decision made in r20 about virtual
	  methods and FieldAccess.  In particular, all virtual methods
	  invoked from a pointer or a reference are represented by
	  a FieldAccess.

12/09/05 UseOA-ROSE svn tag FIAlias r26 	Brian White	
	- Note this is revision 26.  I skipped one somewhere along the line.
	- Fixed getLocation.  It had been ignoring the procHandle.
          It now returns local = 1 only when the declaration of the
          variable is within procHandle.
        - Promoted MemRefExprTestInput.C.out.latest to .C.out
        - Removed a bunch of dead code.
        - Implicit actual for method invocation was being returned by
	  getCallMemRefExpr.  This was a problem since we expect that
          to return only MREs corresponding to methods/functions.  
          This MRE is now returned at the lhs of the dot/arrow expression,
          which _is_ the implicit actual.

12/12/05 UseOA-ROSE svn tag FIAlias r27 	Brian White	
        - Changed getLocation so that it has the correct semantics.
	  For C/C++ these read:
          1.  If sym is local to proc, return a NamedLoc(sym, isLocal = true);
          2.  If sym is global, return a NamedLoc(sym, isLocal = false);
          3.  Otherwise, sym is not accessible in proc, return "null".

12/16/05 UseOA-ROSE svn tag FIAlias r28 	Michelle Strout
	- After some fixes to FIAlias algorithm, started rechecking
    	  the regression tests.  Each test marked as checked has a 
 	  test result generated for it.  Now the equivsets results
	  only show how each MemRefHandle maps to locations.

1/5/06   UseOA-ROSE svn tag FIAlias r29 	Michelle Strout
	- After fixing semantics of EquivSets in OA,
          redid a number of the regression tests.  
          Those that still have issues are marked as checked by ???
          in regressionFIAliasTestsOut.script.

1/9/06   UseOA-ROSE svn tag FIAlias r30 	Brian White
        - Wasn't visiting the SgConstructorInitializer of a SgNewExp
          in SageIRMemRefIterator::findAllMemRefsAndMemRefExprs.
          We treat invocations of a constructor as we treat invocations
          of methods:  as uses of a virtual table entry.
        - Wasn't properly synchronizing actual and formal lists in
          SgParamBindPtrAssignIterator::create due to implicit this.
          The actual list (created by SageIRInterface) includes this,
          while the types of the formals (returned by Sage) does not.
        - Changed the implementation of the reference conversion rules
          to reflect the fact that assignments should be treated
          differently than initializations.  According to Stroustrup:
          "...the value of a reference cannont be changed after initialization;  
           it always refers to the object it was initialized to denote."
          The amended rules:
          // - For every initialization of a referenece:  t_l& lhs = rhs
          //   (including the implicit assigment during parameter binding
          //   and intialization in a constructor's initializer list)
          //  1.  Convert lhs from a reference to a pointer type, t_l *lhs = ...
          //  2.  If the rhs does not have an lvalue (e.g., 3+5, 5, &y, ...),
          //      then replace lhs with *lhs.
          //  3.  Whenever lhs is used on a right-hand side or in an
          //      assignment (lhs = rhs), replace lhs with *lhs.  Since references
          //      are only assigned once (during initialization), a reference's
          //      appearance on the lhs of an assignment modifies the data to which
          //      it refers, not to the reference itself.
          // - For every rhs corresponding to the above initialization cases: t_l &lhs = rhs
          //  4.  If the rhs has an lvalue, then replace rhs with &rhs.
        - Updated TestCases/AliasTests/refCall.C.out and marked as
	  checked in regressFIAliastTestsOut.script.

1/15/06   UseOA-ROSE svn tag FIAlias r31 	Brian White        
        - Fixed isVirtual to check the first non-defining declaration.
          The defining declaration may not be marked as virtual, 
          hence checking it will not suffice.
	- Fixed bug: do not make the Deref of a FieldAccess inaccurate 
          simply by virtue of its being part of a FieldAccess.  Do not 
          change the accuracy of a Deref (from however it was generated).  
          FieldAccess accuracy should be the same as its Deref.  
          i.e., it can not be accurate if its underying MRE is inaccurate.
        - Only generate implicit pointer assignments of the form
          a->"bar" = bar if bar is virtual.
        - Changed implicit ptr assign for vtable optimization from
          < A.method, A::method > to < A.method, &A::method>
          Thus because of the implicit pair 
          ((*a).FieldHandle(OA_VTABLE_STR), &A) FIAlias unions
          (*(*a).FieldHandle(OA_VTABLE_STR) and A.  Because of the
          pair (A.method, &A::method) returned here, FIAlias unions
          *A.method and A::method.  Finally, when getCallMemRefExpr
          returns *(*(*a).FieldHandle(OA_VTABLE_STR).method), FIAlias
          sees that *(*(*a).FieldHandle(OA_VTABLE_STR).method) is aliased
          to *A.method is aliased to A::method.
        - Changed implicit ptr assign generated by 
          createImplicitPtrAssignForMethods from 
          < (*lhsMre).m, C::m > to < (*lhsMre).m, &C::m >.
          Thus, when getCallMemRefExpr() returns *((*lhsMre).m), FIAlias uses
          this implicit pair to bind it to C::m (after dereferencing)
          to perform virtual method resolution.
        - Changed getCallMemRefExpr() to return a Deref for virtual
          method invocations. This, and the above changes, are in line
          with the following philosophy (from Michelle):
	  "getCallMemRefExpr should put a deref around the call if the  
           call is made with a function ptr or made to a virtual method (where
           the field is acting like a function ptr)."
        - Now generate a pointer assign pair if a return statement returns
          a pointer (or reference) type.  The form of this pointer
          assign pair is foo = ret for the case:

             type *foo() {
                 return ret;
             }

	  where foo in the pointer assign pair is a SgFunctionDeclaration.
          FIAlias will union these to *foo = *ret.  This won't collide with
          other uses of foo (e.g., to indicate a function/method) because 
          we don't return foo from as ptr (implicit or otherwise) assigns.  
          We do return &foo from an implicit ptr assign.  Therefore, we 
          will never create *foo except when it indicates a return value.
	     - Updated getAliasStmtType to set PTR_ASSIGN_STMT for
               such a return statement.
             - Modified SgPtrAssignPairStmtIterator::create to 
               create the pointer assign pair for a SgReturnStmt.
        - No longer generate unknown MREs for functions which return
          addresses (i.e., pointers or references).  Instead, create an
          MRE whose symbol is a reflection of the function invoked.
          Note in two cases (virtual method and function pointer), we
          we can do this, though the symbol can instead represent the
          function call expression.  
          The following table shows how we represent the function/method:
	 
                proc type   ret type   lhs = proc
                ---------   --------   ----------
                func        address    lhs = func
                non-addr       --
                (*funcPtr)  address    lhs = *funcPtr
                non-addr       --
                method      address    lhs = method
                non-addr       --
                virtual     address    lhs = *(obj->"fooA")
                non-addr       --

          This MRE is then used to create a pointer assign pair.
          Further, this MRE will match the lhs MRE from a return
          statement pointer assign pair, either directly (in the case
          of func and method) or after unification via an alias analysis
          (in the case of funcPtr and virtual).

1/17/06   UseOA-ROSE svn tag FIAlias r32 	Brian White        
        - Bug fix:  had to strip SgCastExpr off of rhs in 
	  createImplicitPtrAssigns in order to recognize it as a 
          SgNewExp (and so to create implicit ptr assigns)
        - TODO:  need to normalize return statements such that we
          create an implicit ptr assign for each expression within
          the return 
	  (in SgPtrAssignPairStmtIterator::createPtrAssignPairsFromReturnStmt).
          For example,
              return ( a < b ? c : d );
              return ( new D, new E);    // should just return later.
          Solution here is to call general routines which generate
          MRE.
        - Was not generating implicit pointer assigns for 'return (new D)'.
          - SageIRInterface::getAliasStmtType previously determined whether
            a return stmt was a PTR_ASSIGN_STMT by checking if the
            type of the return expression was a pointer/reference.
            Evidently, 'new D' has type SgClassType (why not a pointer).
            It now accounts for this.
          - SgPtrAssignPairStmtIterator::createPtrAssignPairsFromReturnStmt 
            was checking that the return stmt really has a pointer type.
            I removed this check as it is redundant with getAliasStmtType.
        - Modified getLocation to handle SgFunctionDeclarations, which
          may be created to represent return values from the corresponding
          function.  If the SgFunctionDeclaration was called from a procedure
          p consider the symbol (assumed to represent the return expression)
          to be local to p.  Otherwise, return the NULL location-- not
          visible within p.  Also handles constructor invocations.
        - Wasn't creating implicit ptr assign pairs for a return stmt
          (which is implicitly an assignment of the form 'proc = ret',
          for the statement 'return ret' in procedure proc).  Fixed this
          by calling createImplicitPtrAssigns from
          createPtrAssignPairsFromReturnStmt.
        - Replaced calls of getNodeNumber(functionDeclaration) with calls
          to getProcSymHandle; such interposition gives us more 
          control over what we return.  e.g., I changed getProcSymHandle
          to return a handle to a SgFunctionDeclaration with an associated
          SgFunctionDefinition.  This requires searching through the
          program for the proper SgFunctionDeclaration.  To do this
          efficiently, we cache all SgFunctionDeclarations in
          SageIRInterface::mFunctions.
        - Output format in FIAlias seems to have changed with new
          svn OpenAnalysis version, so I re-ran regressFIAliasTestsOut.script.
        - Current status/milestone:  HindEtAlIBM95Fig4.C no longer
          generates an UnknownLoc.  I have not, however, checked it for
          correctness.

1/24/06   UseOA-ROSE svn tag trunk r35 	Brian White        
        - Fixed assertion failure caused by findAllocatedClass 
          returning NULL.  This was caused by isAllocation a 
          SgPointerType rather than a SgClassType (when
          using a newer version of ROSE:  ROSE-January18a-2006,
          unreleased).  
          // Older versions of ROSE (0.8.6c and earlier) were
          // returning SgClassType as the type of SgNewExp.
          // We would like to return a SgClassType, so this is fine,
          // though counter-intuitive.  Dan fixed this so that
          // the type of a SgNewExp is a SgPointerType, which makes
          // more sense.  To maintain backward compatibility,
          // check to see which case we are in.

1/27/06   UseOA-ROSE svn tag trunk r36  Brian White        
        - UseOA-ROSE now works with ROSE-January18a-2006 (unreleased)
          and the current CVS version (0.8.6x).  To select 
          ROSE-January18a-2006, set
                 GLOBAL_DEFINES = -DUNRELEASED_ROSE
          in config/Makefile.inc (and change your paths).
	- NOTE!  There are superficial differences between the output
          generated by ROSE-January18a-2006 and 0.8.6x.  e.g., memory
          references are returned in a different order.  Rather than
          compare these directly, we will maintain a results dir for
          each version.  Regression tests should only compare against
          the version of ROSE which was used to build the library.
          I have added genUnreleased{FIAliasTests,MemRefExprOut}.script
          and regress{FIAliasTests,MemRefExprOut}.script to handle the
          new version.
          Please check against both versions of ROSE!  Sorry.
        - The results for the two versions of ROSE have been checked
          and are consistent (modulo the superficial differences).
          However, I have made local bug fixes which were not
          distributed with ROSE-January18a-2006 to the following
          files:
               src/ROSETTA/Grammar/Node.code
                    The problem is that get_attribute() as defined in 
	            subclasses of SgNode do not seem to overload 
	            SgNode::get_attribute().  The problem is that
                    SgNode::get_attribute() is not declared const, 
	            though it is virtual.  All other get_attribute() methods 
	            are declared const.  Evidently, this difference suffices 
	            to prevent get_attribute() (non-const) to be invoked
                    as a virtual method (upon a SgNode, rather than say 
	            a SgInitializedName).

                    The fix is simple:  just add const to the declaration 
	            and definition of SgNode::get_attribute().  
	            In src/ROSETTA/Grammar/Node.code around lines
                    278 and 647, just add "const" after "get_attribute()".
               src/ROSETTA/Grammar/Expression.code
                    Modified SgFunctionCallExp::get_type() so that
                    it returns the return value of function calls
                    for dot and arrow expressions.
                    Around this comment:
                    // This returns the type of the referenced data member, but if this is a
	            // function call shouldn't it return teh return value of the function call? 
                    // Yes, it should.  BW and DQ (1/27/06) 
                src/backend/unparser/unparse_expr.C 
	            Removed Dan's debugging statements.
                    Converted #if 1 to #if 0 on lines 958, 962, 1004
                    Commented out lines 576, 580, 1093, 1098, 1110, 1114, 1119, 1122
                    Unparser::unparseBinaryExpr added the following #if 0s:
                    // Special case: 
                    #if 0 
                    cur << "/* Special case of operator[] found */\n"; 
                    printDebugInfo("we have special case: []", TRUE); 
                    printDebugInfo("lhs: ", FALSE); 
                    #endif 
                    unparseExpression(binary_op->get_lhs_operand(), info); 
                    cur <<  "[" ;  
                    #if 0 
                    printDebugInfo("rhs: ", FALSE); 
                    #endif 
                    unparseExpression(binary_op->get_rhs_operand(), info); 
                    cur <<  "]";  
          These have been reported to Dan (except the debugging stmts).
        - Bug fixes for ROSE-January18a-2006:
              - Newer versions of ROSE will support SgNullStatements
                and SgNullExpressions.  To avoid confusing the output
                and regression tests, we do not include SgNullStatements
                in statement iterators (i.e., SageIRStmtIterator,
                findAllStmts).
              - Added wrapper around attribute mechanism,
                SageIRInterface::getAttribute(SgNode*).  This masks
                the fact that attributes are instance variables in
                current versions of ROSE, but are methods in the 
                unreleased and future versions.
	- Changed refParam.C and ref.C slightly so that they would
          output the alias sets I was interested in.
        - After making the above changes to ROSE-January18a-2006, the
          only assertion failures (for either version of ROSE),
	  should be in RinardEtAlPLDI96Fig4.C:
               OATest: Sage2OA.C:4888: virtual OA::OA_ptr<OA::MemRefExpr> SageIRInterface::getCallMemRefExpr(OA::CallHandle): Assertion `numMres == 1' failed.

1/27/06   UseOA-ROSE svn tag trunk r39  Brian White
        - Checked the following for both versions of ROSE, updated the
          regress*.script to show they have been checked, and updated
          the regression results:
               RyderEtAlFig15.c
               RyderEtAlFig9.c
               RyderEtAlFig2.c
               RyderEtAlFig1c.c
               RyderEtAlFig1b.c
               YongEtAlPLDI99.c
               ref.C
               refParam.C
               refClass.C
        - The following test cases still need to be checked nor have they
          been checked for consistency between released and unreleased versions
               PandeEtAlRutgers05.C
               HindEtAlIBM95Fig4.C
               HindEtAlISSTA00Fig1.C
               LattnerEtAl03Fig1.C
               RinardEtAlPLDI96Fig4.C
        - Added collect[Unreleased]{MemRefExpr,FIAliasTests}Out.script
          scripts to concatenate all results saved in TestResults/
          to a single file.  I found it useful to create a single
          file for each version of ROSE and then to do an mgdiff on 
          those files.  
        - Changed SageIRInterface::toString to annotate references
          in "some" cases:
          // If an initialized name is a reference, then we model
          // it is a pointer.
          // e.g., int &lhs = ... -> int *lhs = ...
          // However, subsequent assignments (different from initializations)
          // of lhs change the value at the location not of the location:
          // e.g. lhs = 5 -> *lhs = 5
          // In OpenAnalysis, *lhs will result in two mem ref expressions:
          // *lhs and the sub mem ref expr lhs.  We wish to differentiate
          // between this "sub" lhs and the above lhs in the initialization.
          // Therefore, we will annotate the lhs initialization here with
          // an "&":
        - Previously, constructors invoked as:
              foo f(arg);
          were not registered as function calls, though those invoked
          via new were:
              foo *f = new foo(arg);
          This happened because FindCallsitesPass::visit was only collecting 
          SgFunctionCallExp and SgNewExp.  Instead, changed
          FindCallsitesPass::visit to collect SgFunctionCallExps and
          SgConstructorInitializers.  The latter are involved in both
          of the above cases.  This effectively changes the mapping of
          an OA::CallHandle from SgFunctionCallExp and SgNewExp to
          SgFunctionCallExp and SgConstructorInitializer.  The following
          methods which acted up OA::CallHandles thus were also changed:
              SageIRInterface::getFormalTypes
              SgParamBindPtrAssignIterator::create
              SageIRInterface::getCallMemRefExpr
              SageIRInterface::getCallsiteParams
          Replaced getNewLhs with getConstructorInitializerLhs.
        - We weren't visiting constructor args!  Added this to
          SgConstructorInitializer clause of 
          SageIRMemRefIterator::findAllMemRefsAndMemRefExprs.
          Also added clause to handle SgConstructorInitializer in
          SageIRInterface::getChildrenWithMemRefs.
        - We have been treating constructor invocations as USEs,
          using the method as the symbol.  This does not work for
          built in types, nor would we consider it a use in such
          case.  Therefore, modified
          SageIRMemRefIterator::findAllMemRefsAndMemRefExprs s
          that it does not treat constructors as uses if they
          create a basic type (i.e., not a SgNamedType).
        - Similarly, do not create implicit ptr assign pairs
          for basic types.  Modified 
          SageIRInterface::createImplicitPtrAssigns to check for this
          condition.
        - Only consider a constructor invocation to be a function
          call (with an OA::CallHandle) if it creates a named type.
          Change to  FindCallsitesPass::visit.  Otherwise, we have
          problems when this call handle is later passed to routines
          which expect it to be backed by a function/method with, say,
          a declaration.
        - Fixed assertion failure in 
	  TestCases/AliasTests/RinardEtAlPLDI96Fig4.C:
              OATest: Sage2OA.C:5037: virtual OA::OA_ptr<OA::MemRefExpr> SageIRInterface::getCallMemRefExpr(OA::CallHandle): Assertion `numMres == 1' failed.
              Abort
          The problem was that 
          SageIRMemRefIterator::findAllMemRefsAndMemRefExprs was not
          creating an MRE for arrow/dot expressions representing
          method calls which neither return an address nor are
          virtual method calls (since there is no MRE for these cases).
          However, getCallMemRefExpr expects these general routines
          to create an MRE in such cases and so invokes 
          getMemRefExprIterator which returns the cached (NULL)
          set of MREs.  Modified getCallMemRefExpr to create
          an MRE explicitly for this case.
        - Modified the condition for SgAddOp/SgSubtrcatOp to have an
          MRE, as returned by SageIRInterface::isMemRefNode.
          If the type of either the lhs or the rhs is a SgArrayType
          (or SgPointerType, as previously) return true.  
        - We weren't handling switch statements.  Added clause
          to visit the selector/condition of a SgSwitchStatement
          in findIndependentMemRefs.  Also, added clauses for
          SgSwitchStatement and SgCaseOptionStmt in 
          SageIRStmtIterator::FindAllStmts so the statement iterator
          visits switches and their bodies.
        - Added array/pointer arithmetic examples to MemRefExprTest.C
        - MemRefExpr case in OATest was not visiting all functions.
          Fixed.

2/14/06   UseOA-ROSE svn tag trunk r42  Brian White	
        - Checked the following for both versions of ROSE, updated the
          regress*.script to show they have been checked, and updated
          the regression results:
               LattnerEtAl03Fig1.C
        - All regression tests passed (for those which have been checked)
          using OpenAnalysis revision 40 and both ROSE-0.8.6c and
          ROSE-January27a-2006.
        - Henceforth we will check regression tests against the ROSE
          repository and ROSE-January27a-2006 rather than 
          ROSE-January-18a-2006.
        - The following test cases still need to be checked nor have they
          been checked for consistency between released and unreleased versions
               PandeEtAlRutgers05.C
               HindEtAlIBM95Fig4.C
               HindEtAlISSTA00Fig1.C
               RinardEtAlPLDI96Fig4.C
        - Fixed bug in SgConditionalExp of 
          SgPtrAssignPairStmtIterator::createPtrAssignPairsFromAssignment
          that was creating an implicit pointer assignment for the
          conditional expression rather than the true and false
          expressions.

3/9/06   UseOA-ROSE svn tag trunk r45  Brian White		
        - **** This version of UseOA-ROSE is incompatible with
          versions of OA prior to 86 because of the following change:
        - Updated OATest to use ManagerFIAliasEquivSets and 
	  ManagerFIAliasAliasMap instead of ManagerFIAlias.
          --oa-FIAlias is replaced by --oa-FIAliasEquivSets and
	  --oa-FIAliasAliasMap.  Actually --oa-FIAlias is equivalent
	  to --oa-FIAliasEquivSets (but should be deprecated).
        - **** UDDU Chains needs an alias manager.  This continues
          to use the equiv sets FIAlias, rather than the new
          ManagerFIAliasAliasMap.
        - Added new results directories for FIAliasAliasMap results
          and new scripts for FIAliasAliasMap manager.
        - Moved scripts to scripts/ directory.
        - I have checked the following FIAliasAliasMap using OA rev 76:
  	       alias1.c
               alias2.c
               alias3.c
               alias4.c
               alias4b.c
	  Note that alias4b.c maps *a to a new UnknownLoc location, 
          rather than to the zero LocationSet with UnknownLoc, which
          would have been more efficient spatially.  Doing this
          right would require remapping an existing set to zero, a la
              AliasMap::remapMemRefs(int oldSetId, int newSetId)
          But invoking this method is extremely unsafe unless you 
          know what it is doing.  In particular, it may change
          the mapping of a set to its id for some set other than
          oldSetId (in particular, the lastSet).  This will wreak
          havoc with ManagerFIAlias which keeps a map from ufset ids
          to AliasMap set ids.  The right way to do this is to
          have AliasMap export one set of ids which may be arbitrary
          but use a different set internally which are contigous.
        - At this point we are switching development to use
          FIAliasAliasMap rather than FIAliasEquivSets.
        - Status of FIAliasEquivSets, all tests passed except the following:
               PandeEtAlRutgers05.C
               HindEtAlIBM95Fig4.C
               HindEtAlISSTA00Fig1.C
               RinardEtAlPLDI96Fig4.C	

3/17/06   UseOA-ROSE svn tag trunk r46  Brian White			
        - Changed getLocation to always return a location for a
	  function/method:
      // We had problems in which a method didn't appear visible but
      // should have been in PandeEtAlRutgers05.C.
      // In main, p and q have static type Base, though they may
      // dynamically be Derived.  Thus, ROSE can only report that
      // the SgFunctionDeclaration for p->foo or q->foo is 
      // Base::foo (as per the static type of p and q).  Thus, it
      // does not see that Derived::foo is called (i.e., when 
      // we ask for all function/method invocations via querySubTree
      // below).  Hence, the logic dictates that since Derived::foo is
      // not main and is not invoked from main, it is not visible in
      // main.  Clearly, this isn't true.
      //
      // For now, the solution is simply to call all functions/methods
      // visible.  This isn't true given static functions, private methods,
      // etc.  There is probably some way to resolve this in ROSE using
      // the context-specific symbol tables, but I have little 
      // experience there and we have a deadline.
      // MMS and BW 3/16/06

3/21/06   UseOA-ROSE svn tag trunk r47  Brian White			
        - Changed createImplicitPtrAssignForMethods so that it does
          not create an implicit ptr assign for a virtual method m
          if it has already created one for a virtual method m'
          which overrides m.  Without this, two methods
          with the same mangled name would have overlapping locations.
        - Modified classHasVirtualMethods so that it returns true
          not only if a class defines a virtual method, but if
          any of its base classes does.
        - Added two isObjectDeclaration methods that create implicit
          ptr assigns for an object declaration/instantation, such
          as A a;  previously we only did this for A *a = new A;
          Though virtual methods can be statically resolved for 'a',
          I think we need to create implicit ptr assigns for cases
          such as A *b = &a.
        - Made a change to SageIRStmtIterator:
  // If the functionDefinition is for main, include all of the 
  // global _object_ declarations and class definitions.  Why?  
  // Because alias analysis (and presumably others) will need to visit 
  // these to create implicit ptr assign.  However, these analyses
  // take an iterator over procs, which would exclude the global-level
  // statements.  
  // NB:  the intent is _not_ that these will be considered local to
  //      main.
        - PandeEtAlRutgers05.C.out passed for AliasMap released and
          unreleased!

3/23/06   UseOA-ROSE svn tag trunk r48  Brian White			
        - Changed SgParamBindPtrAssignIterator::create because it
          was not correctly handling the param bindings for
          a constructor invoked as 'A a;' rather than 'A *a = new A;'
          In the former case, we need to take the address of a
          before binding to this.
        - We were incorrectly treating variables declared within
          inlined methods (i.e., methods declared within the scope
          of a class) as if they were declared within the class
          (which I took to be synonymous with members of that class).
          This was an issue in createMRE which adds an implicit 'this->'
          to member variables if they have not already been added by ROSE.
          i.e., a form of normalization.  ROSE does this already
          in most, but not all, cases.  The change is actually
          in getDefiningClass:
  // In the following example:
  // class vector {
  //  public:
  //  void vecAdd(double v[NDIM]) {
  //    for(int i = 0; i < NDIM; i++)
  //      val[i] += v[i];
  //  }
  // };
  // i is technically defined within the class, since it
  // is defined within vecAdd which is defined within the
  // class.  But this method, getDefiningClass, really
  // wants to return the class of which a variable is a member.
  // therefore, if we find a scope along the way that is
  // a function/method, we should return false.

3/24/06   UseOA-ROSE svn tag trunk r49  Brian White			
        - Fixed getLocation to properly handle 'this' pointers.
          i.e., previously we were always identifying them
          as local.
	- I've added an indirect call site "analysis"
          staticVirtualMethodResolver.C.  Should be close
          to working.  Unfortunately, ROSE doesn't see the
	  class definition in Pande:
        // class Base {
        // public:
	//  virtual void foo();
        //  virtual void bar();
        //  virtual void baz();
        // } *a, *b, *p, *q;

3/26/06   UseOA-ROSE svn tag trunk r52  Brian White
        - Fixed bug in getLocation:  when comparing two 
          get_firstNonDefiningDeclarations for equality, need to 
          first ensure they aren't NULL.  This bug was manifest as
          this::this::foo being visible in this::this::bar.
        - Added mangled names to symhandle output for "this:" and "method:".
          Output is now this::scope::method_name__mangled_method_name.
          I output both the method_name and the manged_method_name,
          as opposed to simply the mangled_method_name, because
          constructor and destructor mangled method names aren't
          really intelligible.
        - Passed HindEtAlISSTA00Fig1.C!
	- Passed HindEtAlIBMFig4.C!

4/06/06   UseOA-ROSE svn tag trunk r53  Brian White
        - Updated FindCallsitesPass::visit to return a SgCastExp
          instead of a SgFunctionCallExp for a malloc.  This is
          consistent with findAllMemRefsAndMemRefExprs which creates
          an MRE for malloc for SgCastExp rather than a SgFunctionCallExp.
        - Updated getCallMemRefExpr to expect SgCastExp representing
          malloc.
        - Updated getFormalTypes, SgParamBindPtrAssignIterator::create,
          and getCallsiteParams to expect a SgCastExp for a malloc.
        - Changed getCallMemRefExpr such that it never relies
          on the general findAllMemRefsAndMemRefExprs routine to create
          a call MRE for a non-pointer dereference function call (not
          a method call).  i.e., previously it would use the general
          routines if the function returned an address.  I have removed
          this conditional.  It wasn't doing the right thing and
          relies too much on internal knowledge of 
          findAllMemRefsAndMemRefExprs.  In particular, 
          findAllMemRefsAndMemRefExprs will create an MRE for 
          an address-returning function  at a SgFunctionCallExp,
          not using a SgFunctionRefExp as I had been attempting to do.
        - Fixed Michelle's problem from 3/30:
          Line numbers are for Rinard

          #:      MemRef          ShouldBe                Is
          19: val[i]                      *this                   this
          84: n->pos.val[i]       *n                              n
          84: pos.val[i]          *this                   this

          I was discarding the Deref in the SgPntrArrRefExp case:
          // Huh?  BW 4/6/06
	  // I don't understand why I was taking the base MRE from an MRE
	  // and discarding the Deref.
	  //	  arrMemRefExpr = copyBaseMemRefExpr(baseAccess);
	  arrMemRefExpr = baseAccess->clone();

          I also made in the SgArrowExp/SgDotExp case around this 
          rather confused comment:
	  // Huh?  BW 4/6/06
	  // I don't understand why I was taking the base MRE from an MRE.
	  //	    arrowOrDotMemRefExpr = copyBaseMemRefExpr(rhsMre);
	  // OK.  I think I understand:  I wanted to model (*a).foo and
	  // a->foo the same way.  Since we model a->foo as a
	  // NamedRef(a, accuracy = false), I wanted to do the same
	  // for (*a).foo.  So, fine, just take the base MRE.
	  // BW 4/7/06:  No!  This isn't true.  We model a->foo
	  // as an inaccurate NamedRef in the previous conditional.
	  //	    arrowOrDotMemRefExpr = copyBaseMemRefExpr(lhsMemRefExp);
	  arrowOrDotMemRefExpr = lhsMemRefExp->clone();
        - Neither HindEtAlIBM95Fig4.C nor PandeEtAlRutgers05.C match
          their regression results.  For Hind, the difference is
          in the q.data within the method ChangeData.  It is now
          getting mapped to UnknownLoc since this reference q is now
          properly being modeled as a pointer.  This still seems wrong;
          it should be mapped to InvisibleLoc.
	

4/12/06   UseOA-ROSE svn tag trunk r55  Brian White	
        - Fixed this bug from Michelle (Subject: Next snag for Rinard, 4/10/06)
	  "Then I look at the output from running OATest 
	   --oa-FIAliasAliasMap on  Rinard.  In Phase 3, I am not getting 
	   the correct ParamBindPtrAssign  pairs for line 112
               d = this->computeInter(n, tmpv);
           but I am getting the correct pairs for line 114
               acc.vecAdd(tmpv);
           For line 112, the implicit assignment to this is missing."
        
           The problem was that some functions were iterating over
           actuals by iterating over the SgExprListExp associated with
           a function call's expression list.  This does not contain
           the implicit actual corresponding to this.
           Updated the following methods to instead invoke
           SageIRInterface::getCallsiteParams which does return the
           this actual folded into the parameter list:
           getChildrenWithMemRefs
           findAllMemRefsAndMemRefExprs

4/13/06   UseOA-ROSE svn tag trunk r59  Brian White		
        - Mostly minor bug fixes.
        - Fixed 3 places in findAllMemRefsAndMemRefExprs which iterate
          over formals/actuals to determine whether an actual is
          treated as a reference (though it may not itself be 
          a reference).  At issue was the handling of varargs.
          In those cases, there are no formals from which we
          can determine how the actual is handled.  Instead, we
          just assume the type of the formal is the same as the actual.
          NB:  we are only trying to determine if the actual is
          a reference, so we don't care about getting subtype info 
          correct.  It isn't clear that this assumption is valid.
          e.g., if we have a function call:
             int a;
	     foo(a); 
          And foo has varargs and treats its arg as a reference,
          we could be in trouble.
	- NOTE!  varargs generate ptr assign pairs between actuals
          and lhses.  We don't currently handle this.
        - Other notes on varargs:
	  - getFormalForActual maps all actuals corresponding to
            a "variable arg" to the last vararg formal.
	    i.e., in 
              foo(a, b, c);
	    with
              void foo(int x, ...);
            b and c map to ... since we return the last ordinal
            formalId for both b and c.  This is not a change
            in the code, just a clarification.
          - getCallsiteParams just does the right thing; it
            returns a, b, and c, as you would expect.
          - Modified findAllMemRefsAndMemRefExprs such that at an
            assignment
	         type lhs = va_arg(va_list, type);
            we create the pointer pair:
                 lhs = formal(...);
            i.e., we map the lhs of any va_arg assignments to the
            last formal.
	  - UPSHOT:  Since we map all lhs of lhs = va_arg to the
            vararg formal and since we map all "variable" actuals
            to this same formal, we effectively map all of the lhs of
            va_arg assignments:
	    void foo(int x, ...):
	         lhs1 = va_arg(ap, type1);
	         lhs2 = va_arg(ap, type2);
	         lhs3 = va_arg(ap, type3);
            to all of the actuals, v1, v2, and v3:
                 foo(x, v1, v2, v3);
            Thus, lhs1 = v1, lhs1 = v2, lhs1 = v3, etc.
            A conservative approximation to the truth.
        - Bug fix in getClassDeclaration.  Wasn't accounting for the
          possibility of recursive typedefs.
        - Bug fix in findAllMemRefsAndMemRefExprs SgFunctionCallExp
          case.  Was not visiting the pointer expression in the
          case of a function call through a pointer.
        - SageIRMemRefIterator::handleDefaultCase wasn't returning a list
          of MREs created from the AST it was passed!

4/24/06   UseOA-ROSE svn tag trunk r64  Michelle Strout
	- Moved CtoOA driver into this directory.
	- Moved NotationGenerator class that CtoOA uses into 
	  OpenAnalysis/src/OpenAnalysis/Alias since it is generic
	  to any implementation of AliasIRInterface
	- Created scripts/AliasIRInterface.test to keep track of
	  testing SageIRInterface as an AliasIRInterface.

5/11/06   UseOA-ROSE svn tag trunk r66  Andy Stone
        - Fixed bug #7317: Comma semantics not properly modeled.  The comma
          operator was incorrectly returning the left hand value operand of the
          right hand operand.

6/9/06    UseOA-ROSE svn tag trunk r70 Michelle Strout
      - changed how it is calling ManagerFIAliasAliasMap based on OA change
        of interface
      - added a test file in TestCases/AliasTests to look at some of the
        CallGraph behavior and FIAliasAliasMap behavior with missing
        functions.

6/12/06    UseOA-ROSE svn tag trunk r71 Andy Stone
    - I've updated UseOA-ROSE so that it works with the latest version of ROSE,
      version 0.8.7a. The necessary changes entailed:
        - Commenting out all places where <config.h> was #included
        - Changed the SageIRInterface::getAttribute() function in Sage2OA.C.

6/12/06    UseOA-ROSE svn tag trunk r72 Andy Stone
    - Added OABenchmark script.  View the script for information about its
      purpose and usage.
    - Added PROFILE_OPTIONS Makefile variables to Makefile.inc.  This variable
      should be used to specify what debugging and profiling flags should be
      passed to the compiler and linker (ex. -O0 -g -pg).  Also modified
      Makefile and OAWraps/Makefile to take advantage of this new variable.

6/13/06    UseOA-ROSE svn tag trunk r73 Andy Stone
    - Fixed a very simple bug in createPtrAssignPairsFromAssignment.  The
      left hand side of the pointer assignment pair was incorrectly being
      set to the left hand side of the comma operator expression.

6/19/06    UseOA-ROSE svn tag trunk r75 Andy Stone
    - Added TestCases/AliasTests/smg2000-typedefStruct.C.  This case models an
      error I found in the smg2000 program <http://tinyurl.com/lvtoo>.
    - Updated the OABenchmark python script so that it can now read in a
      CXXFlags variable from the files file.

6/21/06    UseOA-ROSE svn tag trunk r77 Michelle Strout
    Fixed OATest.C so that it works with OpenAnalysis rev 118 where
    I fixed CallGraph construction so that it uses alias analysis results.
    We still need to set up some regression tests for this.

6/22/06    UseOA-ROSE svn tag trunk r78 Michelle Strout
    Added a regression test for Andy's fix of the comma bug.  Original bug:
    ./CtoOA TestCases/AliasTests/comma.c results in incorrect PTRASSIGNPAIRS
    for StmtHandle("p =((q = &x) , r);"). p should get assigned to r not q.

6/23/06    UseOA-ROSE svn tag trunk r79 Andy Stone
    - Added 10 regression tests for the FIAliasAliasMap.  These tests are
      for alias1.c, alias2.c, alias3.c, alias4.c, alias4b.c, comma.c,
      funCall.c utke.c, OAWikiEx.c, and constQualified.c.  Also added
      template.test to the scripts directory.

6/26/06    UseOA-ROSE svn tag trunk r80 Andy Stone
    - Added regressFIAliasAliasMap.script and genFIAliasAliasMap.script which I
      forgot to add in r79.

6/26/06    UseOA-ROSE svn tag trunk r81 Andy Stone
    - Added regression tests for AliasIRInterface.  These tests are
      for alias1.c, alias2.c, alias4.c, and alias4b.c.

6/27/06    UseOA-ROSE svn tag trunk r82 Luis Ramos  
    - Added regression test for CallGraph. These test is for functionPtr.c 

6/27/06    UseOA-ROSE svn tag trunk r83 Andy Stone
    - Removed regression test "stuff" for the old unreleased version of ROSE.
      This included removing:
      - TestResults/UnreleasedFIAlias
      - TestResults/UnreleasedMemRefExpr
      - TestResults/UnreleasedCFG
      - TestResults/UnreleasedFIAliasAliasMap
      - scripts/genUnreleasedCFGTestsOut.script
      - scripts/UnreleasedCFG.test
      - scripts/genUnreleasedFIAliasTestsOut.script
      - scripts/UnreleasedFIAlias.test
      - scripts/genUnreleasedFIAliasAliasMapTestsOut.script
      - scripts/collectUnreleasedFIAliasTestsOut.script
      - scripts/UnreleasedFIAliasAliasMap.test
      - scripts/genUnreleasedMemRefExprOut.script
      - scripts/collectUnreleasedFIAliasAliasMapTestsOut.script
      - scripts/regressUnreleasedFIAliastTestsOut.script
      - scripts/regressUnreleasedMemRefExpr.script
      - scripts/regressUnreleasedCFGTestsOut.script
      - scripts/collectUnreleasedMemRefExprOut.script
      - scripts/UnreleasedMemRefExpr.test
      - scripts/regressUnreleasedFIAliasAliasMapTestsOut.script

6/27/06    UseOA-ROSE svn tag trunk r84 Andy Stone
    - Added and verified two scripts for function pointers.  functionPtr.c was
      taken from Luis's work in the CallGraph tests, functionPtr2.c is a
      version with more complicated aliasing issues.

6/27/06    UseOA-Rose svn tag trunk r85 Barbara Kreaseck
    - config/Makefile.inc has paths for me on armstrong

6/27/06    UseOA-Rose svn tag trunk r86 Andy Stone
    - I previously forgot to add functionPtr.c and functionPtr2.c into the
      TestCases/AliasTests directory, they are now added.

6/27/06    UseOA-Rose svn tag trunk r87 Priyadarshini Malusare
     - I added driver for ReachDef in OATest.C but its not working yet.
       This is just for Michell  	  

6/27/06    UseOA-Rose svn tag trunk r88 Priyadarshini Malusare
     - I added TestCases for ReachDef Analysis

6/27/06    UseOA-Rose svn tag trunk r89 Priyadarshini Malusare
     - I added ReachDef Tests
	
6/27/06    UseOA-Rose svn tag trunk r90 Priyadarshini Malusare
     - I added genReachDef.script
	
6/27/06    UseOA-Rose svn tag trunk r91 Priyadarshini Malusare
     - I added regressReachDef.script

6/28/06   UseOA-ROSE svn tag trunk r92  Brian White			
        - Modified isMethodCall so that it returns false for 
          static method calls.  isMethodCall is used to determine
          whether we need to pass an implicit "this" to model a 
          method.  We don't need to do this (and can't) for a static
          method call.
        - Modified SageIRInterface::toString(const OA::CallHandle h) 
          to output a function call which is an invocation of a copy
          constructor implicitly called by a return.
        - I started working on handling of special methods (next
	  entry).  However, Dan wanted this behavior in ROSE so that
	  it could be "enjoyed" by any ROSE analysis.  Therefore, I
	  have commented out my implementation of this behavior.
	  Note that it was not finished.  See comments that look like:
          // Support for special methods, which is now handled in ROSE.
        [ Handling of compiler-generated default constructors, copy
          constructors, destructors, and operator=.
	
	  - Modified getAliasStmtType to return PTR_ASSIGN_STMT when:
            1.  stmt is operator= and one of the implicitly invoked
                operator= along the call chain (if any) would 
                implicitly copy a point.  
                NB:  the default behavior of operator= is to do a
                     memberwise copy.
            2.  stmt invokes a copy constructor:
	        NB:  the default behavior of a copy constructor is
                     to perform memberwise copy.
                a.  case Foo *f = new Foo(*someOtherFoo) is already
                    handled by SgAssignOp case, which always returns
                    PTR_ASSIGN_STMT.
                b.  case Foo f(someOtherFoo) is handled by 
                    SgVariableDeclaration case which returns true
                    whenever an object is declared.
                c.  case f(someOtherFoo) within a copy constructor.
	            Return PTR_ASSIGN_STMT if some compiler-generated
                    copy constructor invoked prior to a user-defined
                    copy constructor would implicitly copy a ptr
                    field (i.e., it's class has (non-method) pointer members).
	    3.  destructors.  Since a default destructor would not
                implicit perform pointer assignments, we don't need to
                model anything here.
            4.  default (i.e., zero-arg) constructor.  Same as destructor
	        case.
         ]
	 - In CtoA set the excludeInputFiles to true for the 
	   SageIRProcIterator.  This prevents us from generating output
	   for include files, such as iostream.h
	   bool excludeInputFiles = true;
           procIter = new SageIRProcIterator(sageProject, irInterface, excludeInputFiles);
         - Changes to staticVirtualMethodResolver
	   - Needed to change ClassHierarchyWrapper::ClassHierarchyWrapper,
	     which was not discovering all SgClassDefinitions, because
	     it was querying only for SgClassDefinition and some of these
             are not visited by default traversals/queries.  The example
	     is from Pande.C.  Unfortunately, this is external to 
	     UseOA and needs to be passed to Dan for checkin to ROSE.
                // Unfortunately, SgClassDefinitions are not always visited by
                // query and traversal mechanisms.  Consider this example:
                //  class Base {
                //  public:
                //    virtual void foo() { }
                //    virtual void bar() { }
                //    virtual void baz() { }
                //  } *a, *b, *p, *q;
                // The SgClassDefinition for Base only shows up in the 
                // SgVariableDeclarations of *a, *b, etc.  Therefore, we need
                // to query the SgVariableDeclarations as well.
           - Replaced methodOverridesVirtualMethod with 
             matchingMemberFunctions, which properly compares two
             method type signatures.
	   - Allow dot expression involving a reference lhs to 
             be examined as potential dynamic dispatch sites,
             rather than just pointer receivers.
	   - This should now be ready for the big time.
         - Fixed the following bug reported by Andy on June 8th.
	
           From: "Andy Stone" <aistone@gmail.com>
           Date: June 8, 2006 11:01:11 AM MDT
           To: "Michelle Strout" <mstrout@CS.ColoState.EDU>
           Subject: FIAliasAliasMap fails with 'variable << endl'
           
           Michelle,
           
           The FiAliasAliasMap algorithm doesn't seem able to handle any
           situation where a variable is passed to an I/O object and endl is
           passed immediatly after or immediatly before this variable. For
           instance: cout << variable << endl.
           
           
           
           Error Message:
           
           $ ./OATest -edg:w --oa-FIAliasAliasMap -c breakuseoa.cpp
           OATest: Sage2OA.C:6886: virtual
           OA::OA_ptr<OA::IRCallsiteParamIterator>
           SageIRInterface::getCallsiteParams(OA::ExprHandle): Assertion
           `isMemRefNode(lhs)' failed.
           Aborted
           
           
           
           I've tried a few other cases to see if I can't determine exactly
           what
           reproduces this problem. For instance
           
           These work:
           - cout << variable;
           - cout << variable << " string constant " << endl;
           - cout << endl << " string constant " << variable
           
           These don't (they reproduce the error):
           - cout << variable << endl;
           - cout << endl << variable;
           - cerr << variable << endl;
           
           
           I've been playing around with GDB trying to see if I can't figure
           out
           exactly what's causing this issue. Let me know if you have any
           ideas.
           
           Thanks,
           -Andy
	
           Fix: isMemRefNode(functionCallExp) was aborting for 
	   ostream &ostream::operator<< and friends, because
	   SageIRInterface::returnsAddress was not doing the correct
           thing.  isMemRefNode should return type for a function/method
           that returns a pointer or reference.  However, returnsAddress
           (called by isMemRefNode) was looking at functionCallExp->get_type().
           I believe in a previous version of ROSE this return the
           type of the function call expression.  Now it is 
           return a SgFunctionType.  I corrected returnsAddress
           to expect a SgFunctionType.
        - Fixed [Bug #7963] Deref of "this" being passed as implicit param.
	  Added a regression test invokeBaseCtor.C in TestCase/CtoOA
          and corresponding {regress,gen}CtoOA.test files.
          Bug log:
Project: UseOA-ROSE
Category: None
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: mstrout
Assigned to : bwhite
Summary: Deref of "this" being passed as implicit param

Details: ./CtoOA TestCases/AliasTests/parambinds-formals.C 

    PARAMBINDPTRASSIGNPAIRS = { CallHandle("SubClass") =>
        [ 
            < 0, Deref( DEF, NamedRef( USE,
SymHandle("this::SubSubClass::SubSubClass__SubSubClass__scope__SubSubClass____MF
b_SubSubClass__Fb_v_Gb___Rb__Base__Re____sep____Rb__i__Re___Fe_"), F, full), 1,
T, part) >
            < 1, NamedRef( USE, SymHandle("par"), F, full) >
        ] }

The zeroth parameter should be a NamedRef to this, not a Deref.

Follow-Ups:

Date: 2006-Jun-26 18:10
By: bwhite

Comment:

Fix is in SageIRMemRefIterator::findAllMemRefsAndMemRefExprs and will be
committed in UseOA rev81 (or my next release thereafter if someone beats me to
the punch).

See case V_SgIniitliazedName.  Problem was that I assumed all SgInitializedName
were initializations of an explicit lhs with a rhs.  e.g. 'mInt(0)' below.

class Foo {
  Foo() : mInt(0);
  int mInt;
}
However, consider the case below where a SgInitializedName is initialized by a
SgConstructorInitializer in a SgCtorInitializerLIst, as in SubClass below:
	
class SubSubClass : public SubClass {
   public:
      SubSubClass(Base &par, int &aint) : SubClass(par) { }
};

Here SubClass appears as a SgInitializedName within the AST.  However, it is
not a variable, but rather represents the base class constructor.  So, in fact,
the MRE that we create here will not be for a LHS, but for the implicit this
actual argument that we pass as the first argument to SubClass constructor.
        - Fixed [Bug #7962] Member fields, methods, and functions should be non-local.
Details: ./CtoOA TestCases/AliasTests/parambinds-formals.C

    LOCATION = { < SymHandle("method:SubClass::SubClass____ct__FR4Base_v"),
local > }
    LOCATION = { < SymHandle("this::SubClass::SubClass____ct__FR4Base_v"),
local > }
    LOCATION = { < SymHandle("par"), local > }
    LOCATION = { < SymHandle("myParent"), local > }

myParent and the method should not be local.

    LOCATION = { < SymHandle("foo_ref1"), local > }

neither should foo_ref1.  Pretty much all methods, member vars, and function
symbols should not be local.


Follow-Ups:

Date: 2006-Jun-29 10:19
By: bwhite

Comment:
We were setting isLocal = true for all methods and functions in getLocation. 
The comment in those cases (V_SgFunctionDeclaration and
V_SgMemberFunctionDeclaration) is correct, but the flag was set incorrectly, as
Michelle points out.
Fix:  simply set isLocal = false.
Added TestCase/CtoA/localNonLocal.c as a regression test for this bug.
        - Regenerated results for comma.c, constQualified.c, functionPtr.c,
	  and functionPtr2.c (regressFIAliasAliasMap tests) and alias1.c,
	  alias2.c, alias4.c alias4b.c, and comma.c (regressAliasIRInterface), all of which were affected by above isLocal bug.
        - Moved invokeBaseCtor.C and localNonLocal tests to 
	  AliasIRInterface.test and removed CtoOA.test

7/03/06   UseOA-ROSE svn tag trunk r94  Andy Stone
    - Rechecked AliasIRInterface regression tests.

7/05/06   UseOA-ROSE svn tag trunk r95  Brian White
    - Added ./TestResults/CtoOA/localNonLocal.c.out, 
      which I forgot to do previously.
	
7/05/06  UseOA-Rose svn tag trunk r97 Priyadarshini Malusare
	     - Added regression tests and driver for ParamBindings
	       We did not add this to regressAll because, it is not working
	        for UseOA-ROSE on current version of gcc compiler, gcc compiler has some bug,
	       but it is working with UseOA-Open64 Revision 39
	
7/05/06  UseOA-Rose svn tag trunk r100 Priyadarshini Malusare
    - Changed config/Makefile.inc so that people have to set the following
      environment variables: topsrcdir, ROSE_INST_ROOT, OPENANALYSIS_DIR,
      and OPENANALYSIS_ARCH.  See wiki for an example script.
    - Made it so that all of the warnings generated by ROSE are captured
      into the .out files.  Should see no warnings during regression testing.

7/07/06  UseOA-Rose svn tag trunk r103 Barbara Kreaseck
     - updated UseOA-Rose regression outputs to work with OpenAnalysis
       trunk r136, which has changes to CallGraph, and output from CallGraph,
       and some extra spaces in outputting a map in general.

        ==> significant output changes in TestResults/CallGraph/*
        ==> spacing changes in outputs in TestResults/FIAliasAliasMap/*

7/07/06 UseOA-Rose svn tag trunk r104 Barbara Kreaseck
     - commented out the TestCases/CallGraphTests/functionPtr.c test 
       in scripts/CallGraph.test as the CallGraph map is incorrect

7/07/06 UseOA-Rose svn tag trunk r105 Michelle Strout
	- Implemented isParam in Sage2OA.C as per Andy's suggested implementation.
	- Set up some ParamBindings regression tests and put them in
	  regressAll.

7/10/06 UseOA-Rose svn tag trunk r106 Barbara Kreaseck
	- added some test cases for CallGraph

7/10/06 UseOA-Rose svn tag trunk r107 Barbara Kreaseck
	- added/editted some test cases for CallGraph

7/10/06 UseOA-Rose svn tag trunk r108 Barbara Kreaseck
	- finished adding/editing test cases for CallGraph

7/10/06 UseOA-Rose svn tag trunk r109 Barbara Kreaseck
	- really finished adding/editing test cases for CallGraph

7/10/06  UseOA-Rose svn tag trunk r110 Brian White
    - Changes to staticVirtualMethodResolver
      - matchingMemberFunctions now compares a stringified version of
        two methods' return types, rather than the SgNode return types.
      - Changed "accounting" of number of possible virtual method resolutions
	and a callsite-- a pure virtual method is no longer considered
        a possible resolution (since it can not be invoked).  
        Is this correct?  Notice that an alias analysis would count
        this.  e.g., if Parent::foo() is pure virtual and Kid1::foo()
        and Kid2::foo() implement it, then an invocation of foo through
        a pointer has 2 possible resolutions, rather than 3.
    - Fixed [Bug #8092] Return statements that don't return anything cause
      assertion

      Details: Here is an example of where this happens.
      ./OATest -edg:w --oa-ParamBindings -c TestCases/ParamBindings/qsort1.c
      Looks like the logic in SageIRInterface::getAliasStmtType needs modified.
      
      
      Follow-Ups:
      
      Date: 2006-Jul-11 09:35
      By: bwhite
      
      Comment:
      
      An assertion in the V_SgReturnStmt case in SageIRInterface::getAliasStmtType
      was failing.  I was asserting that the return expression from a return
      statement was non-NULL.  This is not true for a void function.  Changed
      the assertion to an if.
      
      Passes qsort1.c
    - Fixed [Bug #8082] UnnamedRefs and PtrAssigns needed at string inits
      Details: When I run the following:
      ./CtoOA TestCases/AliasTests/passArrayPtr.c

      the following statement:
          char a[] = "testing";
      gets only one MEMREFEXPR:
          MEMREFEXPRS = { StmtHandle("char a[] = "testing";") =>
              [
                  MemRefHandle("a") =>
                      NamedRef( DEF, SymHandle("a"), F, full)
              ] }
      There needs to be an UnnamedRef for the "testing" string and a PtrAssign
      otherwise the alias analysis will have *a and anything that aliases it
      access UnknownLoc.
      
      
      
      Follow-Ups:
      
      Date: 2006-Jul-11 09:47
      By: bwhite
      
      Comment:
      
      Added case in SageIRMemRefIterator::findAllMemRefsAndMemRefExprs to
      create a MemRefExpr for strings (case V_SgStringVal).  The MemRefExpr so
      create mirrors that created for new/malloc-- it is inaccurate (since we 
      don't accurately model the statement context) and addressTaken = true 
      since it generates an address.

      To create the pointer assignment pair, changed conditional in
      SageIRInterface::initializerHasPtrAssign which returned false if the 
      type of the lhs was not a pointer or reference so that it doesn't return 
      false if the lhs is an array (i.e., SgArrayType).
      
      ./CtoOA TestCases/AliasTests/passArrayPtr.c now gives the following for
      the string case:
      
          MEMREFEXPRS = { StmtHandle("char a[] = "testing";") =>
              [
                  MemRefHandle("a") => 
                      NamedRef( DEF, SymHandle("a"), F, full)
                  MemRefHandle(""testing"") => 
                      UnnamedRef( USE, StmtHandle(""testing""), T, part)
              ] }
          PTRASSIGNPAIRS = { StmtHandle("char a[] = "testing";") =>
              [
                  < NamedRef( DEF, SymHandle("a"), F, full)
                  , UnnamedRef( USE, StmtHandle(""testing""), T, part) >
              ] }
    - passed passArrayPtr.c and added to regressAliasIRInterface 
      to test above bug fix.
    - Fixed [Bug #7964] Problems with var args
      Details: ./CtoOA TestCases/AliasTests/parambinds-formals.C 
      
          PARAMBINDPTRASSIGNPAIRS = { CallHandle("ellipsis_intptrs(3,&x,&y,&z)") =>
              [
                  < 2, NamedRef( USE, SymHandle("y"), T, full) >
                  < 3, NamedRef( USE, SymHandle("z"), T, full) >
              ] }
      
      PROCEDURE = { < ProcHandle("ellipsis_intptrs"), SymHandle("ellipsis_intptrs") >
      }
          FORMALS = {
              [
                  < 0, SymHandle("x") >
                  < 1, SymHandle("") >
              ] }
      
      Two problems:
              1) where is &x in the PARAMBINDPTRASSIGNPAIRS?
              2) bigger problem: the number of formals don't match the number
                 of actuals
      
      Possible solutions for (2)
      Brian and Andy both suggested modeling this as passing in one structure
      that contains everything.  This would merge everything being passed in
      but I think that is ok.

                < 1, NamedRef( USE, SymHandle("x"), T, full) >
                < 1, NamedRef( USE, SymHandle("y"), T, full) >
                < 1, NamedRef( USE, SymHandle("z"), T, full) >

      
      Follow-Ups:
      
      Date: 2006-Jul-11 12:59
      By: bwhite
      
      Comment:
      
      The first vararg was not being considered for param-bind-ptr-assigns:  
      We only create param bindings
      for pointers/references.  However, for var args we can
      not get the type from the formal, so we need to look at 
      the actual.  SgParamBindPtrAssignIterator::create was
      correctly looking at the actual type in the formal was
      NULL or SgTypeEllipse.  Unfortunately, it would then
      set the type we are considering to the formal type
      anyway, if the we were not at the end of the formal
      list.  This only affected the first vararg, since
      at the second and subsequent varargs, we had
      reached/exceeded the end of the formal list
      and therefore could not get the type from it.
      
      Also assigned each actual corresponding 
      to a vararg in the param-bind-ptr-assign-pairs
      to the same formal parameter number--
      namely the number corresponding to '...'.
      
      After this fix, we get 'x' listed in the
      param-bind-ptr-assign-pairs and have 
      all actuals bound to formal 1:
      
          PARAMBINDPTRASSIGNPAIRS = { CallHandle("ellipsis_intptrs(3,&x,&y,&z)") =>
              [
                  < 1, NamedRef( USE, SymHandle("x"), T, full) >
                  < 1, NamedRef( USE, SymHandle("y"), T, full) >
                  < 1, NamedRef( USE, SymHandle("z"), T, full) >
              ] }
      
      This functionality is tested by parambinds-formals-intPtrs.C,
      which is a subset of parambinds-formals.C.
    - added parambinds-formals-intPtrs.C to test above bug fix.
    - Passes regressAll using ROSE-0.8.7a and OpenAnalysis revision 139.

7/14/06     UseOA-Rose svn trunk r112    Barbara Kreaseck
    - added regression tests for ICFG, added to regressAll
    - added functionality for --oa-ICFG test in OATest.C and OAWraps/
    - passes regressAll with rose-0.8.7a/compile-gcc-3.2 and OpenAnalysis r141 

7/17/06     UseOA-Rose svn trunk r115    Priyadarshini Malusare 
    - added regression tests for SideEffect, not yet added in regressAll.
        - added functionality for --oa-SideEffect test in OATest.C and OAWraps/
	    - passes regressAll with rose-0.8.7a/compile-gcc-3.2 and
	    OpenAnalysis.

7/17/06     UseOA-Rose svn trunk r116    Barbara Kreaseck
    - re-gen'd ICFG regression output to work with OpenAnalysis trunk r147
    - removed TestCases/CallGraph/functions3.cpp from regressCallGraph.script
         because include files are handled differently depending upon which
         ROSE compilation you are working on.
    - added ICFGTest to regressAll
    - passes regressAll with OpenAnalysis trunk r147 
        compiled on Okapi with gcc-3.2 and rose-0.8.7a/compile-gcc-3.2

7/18/06     UseOA-Rose svn trunk r117    Michelle Strout
    - added a SideEffect test
    - regressAll mostly works with OpenAnalysis r150.  There are a couple
      of small diffs that I sent email to folks about.

7/18/06     UseOA-Rose svn trunk r118   Priyadarshini Malusare
   - Added TestCase for SideEffect
     simpleMix.cpp

7/18/06     UseOA-Rose svn trunk r118   Priyadarshini Malusare
   - Modified Sage2OA.h 
	
7/19/06     UseOA-Rose svn trunk r121   Andy Stone
    - Added support for a USEOA_DEBUG environmental variable (for more info
      look at the new debug.h file).
    - added the --skipAnalysis and --exitWithTop command line options.  If
      --skipAnalysis is set then when running when --oa-FIAliasAliasMap the
      analysis will be skipped (the other analyses should be configured to take
      into account this flag as well).  --exitWithTop will cause OATest to
      execute the unix 'top' command immediatley before termination.

7/20/06     UseOA-Rose svn trunk r122   Priyadarshini Malusare
    - Added TestCases for SideEffect Analysis.
	  TestCases/SideEffect/simpleMix-passptr.c,
	  TestCases/SideEffect/stringcmp.c,
	  TestCases/SideEffect/test.c.
	  Also added regressSideEffect.script and genSideEffect.script.
    - SideEffect is not working for TestCases/SideEffect/swap.c
	 
7/23/06     UseOA-Rose svn trunk r123   Priyadarshini Malusare
      - Added ReachDefs regression output to work with OpenAnalysis trunk r161
      - Added TestCases/ReachDefsTests/reachdef_if1.c, reachdef_if1.c,
	    TestCases/ReachDefsTests/reachdef_if2.c,
		TestCases/ReachDefsTests/reachdef_loopif1.c 
      - added ReachDefs to regressAll
      - passes regressAll with OpenAnalysis trunk r161 compiled on Okapi with gcc-3.2 and rose-0.8.7a/compile-gcc-3.2
    
07/24/06   UseOA-Rose svn trunk r124  Priyadarshini Malusare
      - Deleted retPtr.c test from AliasIRInterface.script and
	  FIAliasAliasMap.script. (going to add those in future after checking
	  output in TestResults).

07/24/06   UseOA-Rose svn trunk r125  Priyadarshini Malusare
      - Added TestResults for ReachDefs.
										
07/26/06   UseOA-Rose svn trunk r126  Priyadarshini Malusare
      - Deleted TestResults/SideEffect/*.c.out as they contain debug output.

07/26/06   UseOA-Rose svn trunk r127  Priyadarshini Malusare
      - Added TestResults for SideEffect/InterSideEffect.

07/27/06   UseOA-Rose svn trunk r128  Priyadarshini Malusare
      - Added TestResults for SideEffect/InterSideEffect without debug output
	    Also Modified OATest.C, regressSideEffect.script and
		genSideEffect.script.
			
8/01/06     UseOA-Rose svn trunk r130    Barbara Kreaseck
      - updated OAWraps/Sage2OA.h toString(ConstSymHandle)
        - Assumption is that a ConstSymHandle can be printed using the same
          output routine as a MemRefHandle, just not recognized as suce
        - Could not generate a ConstSymNode in test cases, unable to test
      - updated ParamBindings regression tests to reflect updated/new output
        associated with OpenAnalysis r166
      - updated ICFG regression tests to reflect new output associated with
        OpenAnalysis r166
      - added initial --oa-ICFGDep testing to OATest.C, et.al.
        - needed OpenAnalysis/IRInterface/ActivityIRInterface.hpp functions
        - added marginal/incomplete_with_asserts functions to OAWraps/Sage2OA.*
          - these functions will need more work at a later time
        - ICFGDep results are fine with X = Y + Z, but not with X[i]=Y[i]+Z[i].
        - DID NOT add ICFGDep regression testing to regressAll
      - passes regressAll with OpenAnalysis trunk r166 compiled on Okapi with 
        gcc-3.2 and rose-0.8.7a/compile-gcc-3.2

8/01/06     UseOA-Rose svn trunk r131    Michelle Strout
    Reverified a lot of regression tests due to the change in ManagerFIAlias
    in OpenAnalysis r167.  RegressAll works with OpenAnalysis r167
    and everything compiled with gcc 4.0.2 on armstrong.

8/01/06     UseOA-Rose svn trunk r134    Priyadarshini Malusare
   Added 5 TestCases for AliasIRInterface. 

8/02/06     UseOA-Rose svn trunk r135    Michelle Strout
   Added a number of test cases to AliasIRInterface.
   regressAll works with OpenAnalysis r167

8/10/06     UseOA-Rose svn trunk r147    Barbara Kreaseck
   - OAWraps/Sage2OA.*:
     + changed getIndepLocIter() into getIndepMemRefExprIter()
     + changed getDepLocIter()   into getDepMemRefExprIter()
   - adjusted regression test and output for AliasIRInterface for gcc-3.2
   - passes regressAll with OpenAnalysis trunk r180 compiled on Okapi with 
        gcc-3.2 and rose-0.8.7a/compile-gcc-3.2

8/13/06     UseOA-Rose svn trunk r151    Michelle Strout
    Made minor changes to how setAddressTaken() was being called due to
    its change in semantics in OA.  regressAll works with OpenAnalysis r183.

8/21/06     UseOA-Rose svn trunk r164    Luis Ramos
    fixed compiler error due to the changed from OpenAnalysis/ExprTree.hpp
    in r195 where CallNode needed a CallHandle not a ExprHandle. File changed
    was Sage20A.C

8/23/06     UseOA-Rose svn trunk r165    Priyadarshini Malusare
   - modified OATest.C for ManagerReachDefsStandard

8/24/06     UseOA-Rose svn trunk r173   Priyadarshini Malusare
    - Modified OATest.C for New GraphRefactor.
    - Works with OpenAnalysis trunk r210 compiled on Okapi with gcc-3.2.
    - ICFG TestCases are regenerated to satisfy Node Numbers of New
    GraphRefactor.

8/25/06     UseOA-ROSE svn trunk r180   Priyadarshini Malusare
    - Added driver and TestCases for UDDUChains. 
    - passes regressAll with OpenAnalysis trunk r211 compiled on Okapi with
      gcc-3.2 and rose-0.8.7a/compile-gcc-3.2

8/30/06     UseOA-ROSE svn trunk r183   Priyadarshini Malusare
    - Added TestCases and TestResults for AliasMapXAIF
	- regressAll works with OpenAnalysis r216.

9/02/06     UseOA-ROSE svn trunk r187   Andy Stone
    - Added benchmarking scripts.

9/11/06     UseOA-ROSE svn trunk r206   Priyadarshini Malusare
    - Changed source() to getSource() and sink() to getSink() in the
      DoOpenAnalysis() of OATest.C.
    - Passes regressAll with OpenAnalysis trunk r229 compiled on Okapi with
      gcc-3.2 and rose-0.8.7a/compile-gcc-3.2

8/17/06     UseOA-Rose svn branch-memRefExprRefactor r156   Brian White
   - Began work to incorporate parameter bindings from trunk:
       - These will be created by createParamBindPtrAssignPairs,
         which will be invoked by the SgFunctionCallExp, 
         SgConstructorInitializer, and SgDeleteExp cases of
         findAllMemRefsAndPtrAssigns.
       - Paramter bindings are registered with makeParamPtrPair,
         which puts parameter binding pairs in mCallToParamPtrPairs.
         I suspect, though, that makeParamPtrPair needs to take
         an MRE rather than a MemRefHandle.
       - SgParamBindPtrAssignIterator::create was updated to
         look at mCallToParamPtrPairs.
       - Am making an effort to handle SgDeleteExp, something we
         weren't doing previously.
   - Created a common.C file to hold Rose related utilities.
     Most of these are imported from the trunk.  I am using
     spaces not tabs :)  Let's try not to junk up SageIRInterface,
     as I had been doing, with general routines that can go 
     in common.C.  Possibly needs a name change.
   - Began experimenting with functions that encapsulate the
     mapping from OA::MemRefHandle to Sage nodes.  e.g.,
     changed Michelle's getCallHandle (SgNode -> CallHandle)
     to verify that it is being passed a SgFunctionCallExp,
     a SgConstructorInitializer, or a SgDeleteExp.  This should
     help avoid logical mistakes and also provide a single/few
     places which explicitly codify the mapping between the
     two domains.  Two other related functions/methods are:
     verifyCallHandleType(OA::CallHandle call), which asserts
     that call may be cast to a SgNode that is one of the
     three above types, and verifyCallHandleNodeType(SgNode *node),
     which verifies that node is one of the above three types.
     The idea is that any function/method manipulating
     CallHandles, or SgNodes it expects to be represented by 
     CallHandles, should invoke one of the verify routines
     and should perform conversions only through the getCallHandle
     routine.

8/17/06     UseOA-Rose svn branch-memRefExprRefactor r158   Brian White	
    - Completed SageIRInterface::getCallsiteParams by implementing
      getActuals(SgNode*) in common.C.  
      NB:  getCallsiteParams returns an expression for the
      receiver, which might be unnamed (e.g., new Foo), as the
      first actual.
    - Added the invocation of createParamBindPtrAssignPairs to
      the SgFunctionCallExp, SgConstructorInitialiazer, and
      SgDeleteExp cases of findAllMemRefsAndPtrAssigns.
    - Updated SageIRInterface::createParamBindPtrAssignPairs.
      That logic is essentially unchanged from the trunk.
    - Changed makeParamPtr to take a MRE rather than a MemRefHandle.
      This is necessary for the handling of the receiver, wherein
      we may take the address of the MRE returned from the
      relevant MemRefHandle.

8/20/06     UseOA-Rose svn branch-memRefExprRefactor r160   Michelle Strout
    - moving MRH to + of v+2 when v is a pointer or an array reference type
      this also affects -. 
      Andy these are places you will need to work with to get more precise
      array references.
    - changed the prefix and postfix code to indicate that in the 
      memory reference
      to a in ++a and a++, a is always used before it is defined.  Whether the
      update occurs before or after the use of ++a or a++ is something that
      we will specify when there is someway to indicate ordering between
      MemRefHandles.
    - Added code for creating a pointer assignment at a return statement if
      the return type is a pointer type or a reference type.
    - Implemented MemRefExpr creation for SgArrowExp.

8/21/06     UseOA-Rose svn branch-memRefExprRefactor r165   Michelle Strout
    - added functionality for ifs, whiles, switchs, etc.
    - fixed bug where I was incorrectly removing MemRefHandle associations
      from StmtHandles
    - Got three more regression tests checked

8/22/06     UseOA-Rose svn branch-memRefExprRefactor r166   Brian White
    - Copied getThisExpSymHandle from branch, with some cleanup.
      getThisExpSymHandle uses a SgFunctionParameterList from the 
      enclosing method to represent a 'this' expression.
    - Renamed getEnclosingMethod to getEnclosingFunction and moved
      to common.C.
    - Copied StringVal case from branch to findAllMemRefsAndPtrAssigns.
    - Changed default case of findAllMemRefsAndPtrAssigns to ABORT.
      If you see a case there which is really a no-op, add it 
      to the no-op case.  

8/22/06     UseOA-Rose svn branch-memRefExprRefactor r167   Brian White	
    - Fixed assertion failure in getFormalTypes.  Evidently, a 
      the base type of a SgPointerDerefExp need not be a SgPointerType,
      but may also be a SgFunctionType.
    - Created SageIRInterface::convertReferenceActuals(SgNode *node)
      to take the address of any actual whose formal is a reference,
      i.e., apply our reference conversion rules which model 
      references as formals.  Invoke for SgFunctionCallExp and
      SgConstructorInitializer.  SgDeleteExp has no actuals,
      aside from the implicit reference, which can not be a reference.

8/22/06     UseOA-Rose svn branch-memRefExprRefactor r168   Michelle Strout
    - functionPtr.c, not indicating addressOf when a function name is on
      the rhs of an assignment.  In SgAssignOp, if rhs is SgFunctionRefExpr
      make all of its MREs have addressOf set.

8/23/06     UseOA-Rose svn branch-memRefExprRefactor r171   Michelle Strout
    - SgCtorInitializer list asserting in class.C.out
      Implemented SgCtorInitializer node in findAllMemRefsAndPtrAssigns.
    - SgMemberFunctionRef asserting in class.C.out
      Implemented SgMemberFunctionRefExp node in findAllMemRefsAndPtrAssigns.
    - comma.C, changed SgCommaOpExp so that it is a MemRefHandle and 
      it  gets its MREs from its rhs.

    NOT sure if the UnnamedRefs generated by strings in the printfs is the
    way to go or not.

8/22/06     UseOA-Rose svn branch-memRefExprRefactor r172   Brian White
    - This checkin incorporates the virtual method handling code
      from the trunk, with significant changes.  

      None of this has been tested, but it does not perturb previous
      results.
	
      Major methods are:
      createImplicitPtrAssignPairsForVirtualMethods (modeled after
      createImplicitPtrAssignForMethods from the trunk), 
      createImplicitPtrAssignPairsForDynamicObjectAllocation,
      createImplicitPtrAssignPairsForObjectDeclaration (modeled after
      isObjectDeclaration from trunk),
      createImplicitPtrAssignPairsForClassDefinition (modeled after
      createImplicitVTablePtrAssignFromDefinition from trunk).
	
      createImplicitPtrAssignPairsForVirtualMethods is a utility
      function invoked by 
      createImplicitPtrAssignPairsForDynamicObjectAllocation and
      createImplicitPtrAssignPairsForObjectDeclaration
      For the per-method model, it creates implicit assignments
      for each method given a lhs of a declaration or a dynamic
      allocation.  For the virtual function table model,
      it creates a single assignment from the lhs' "vptr" field
      to a representation of the virtual function ptr table.

      createImplicitPtrAssignPairsForDynamicObjectAllocation is 
      invoked from within makePtrAssignPair; it only acts
      when the rhs of an explicit ptr assignment pair 
      corresponds to a new expression.

      createImplicitPtrAssignPairsForObjectDeclaration is
      invoked from findAllMemRefsAndPtrAssigns in the
      SgVariableDeclaration case.

      createImplicitVTablePtrAssignFromDefinition create the
      virtual function table in that model.  It is 
      invoked in the SgClassDefinition case of findAllMemRefsAndPtrAssigns.

    - Replaced the old #define VTABLE_OPT from the trunk, with
      the boolean member variable mUseVtableOpt.  This is set
      via an optional argument to the constructor, SageIRInterface,
      which defaults to false.
      
      This flag is controlled by the --usePerMethodVirtualModel
      to CtoOA and OATest.

    - created new scripts for NON-virtual method model in
      AliasIRInterfacePerMethodModel.test, etc.

    - Added some new methods to convert between OA handles and
      Sage nodes:

      SageIRInterface::verifyStmtHandleType(OA::StmtHandle stmt);
      verifyStmtHandleNodeType(SgNode *node)

      verifySymHandleNodeType(SgNode *node);
      SageIRInterface::getSymHandle : SgNode -> OA::SymHandle

      getVTableSymHandle(SgClassDefinition *classDefn)
	
    - The proper way to compare types is to stringify them
      and compare, not by pointer comparison on SgTypes.
      Well, this may work, but I don't know that there is
      a single unique SgType for each type.
      Types can be compared via eqTypes class.
      Types may be stringified via getTypeInfo.

    - To mangle function names uses mangleFunctionName.

    - Some utility functions on virtual methods and to 
      determine if two functions/methods "match"-- i.e.,
      have the same type signature and name.

      classHasVirtualMethods
      SageIRInterface::isVirtual
      SageIRInterface::isVirtualWithinDefiningClass
      SageIRInterface::isDeclaredVirtualWithinAncestor
      SageIRInterface::isDeclaredVirtualWithinClassAncestry

      NB:  isVirtual only returns true if the function in question
           is declared virtual in its immediate class.
	
      matchingFunctions(SgFunctionDeclaration *decl1, 
	                SgFunctionDeclaration *decl2)	

    - Some random utility functions:
       
      SgClassDeclaration *getClassDeclaration(SgType *type);
      SgFunctionDeclaration *getDefiningDeclaration


8/24/06     UseOA-Rose svn branch-memRefExprRefactor r176   Michelle Strout
    - fixed bug in SgAssignOp where the lhs was having its addressTaken but
      not having the result set to DEF.  Now refParam.C works in 
      AliasIRInterface.test
    - verified retPtr1.c
    - implemented SgConditionalExp
    - implemented SgSizeOfOp

8/25/06     UseOA-Rose svn branch-memRefExprRefactor r177  Brian White
    - Updated AliasIRInterfacePerMethodModel.test to reflect
      above changes to AliasIRInterface.test.
	
    - Fixed bug:  we were getting a NULL location for static
      member variables.  Changed logic in getLocation to 
      reflect this from Michelle 
      (8/24/06 Subject: Re: missing Location for static class variable)

      All member variables are "not local" in OA terminology. The definition
      of local in OA means that a variable is ONLY visible within that one
      procedure. That is not the case for member variables since even if they
      are private they are visible in all member methods.

      Now we get a location for 'sInt' in class.C
	
    - Fixed assertion failure on line MemSage2OA.C:225 occuring
      in func_call.c as noted by Michelle on 8/24/06
      Subject: Some issues in the refactor

      Simply removed this assertion in favor of a conditional.
      It had been asserting that the SgNode derived from
      a MemRefHandle for an actual was non-NULL.  However,
      if an actual does not reference memory (e.g., 5, sizeof(Foo)),
      then there will be no MemRefHandle and hence no
      SgNode *actual.

8/25/06     UseOA-Rose svn branch-memRefExprRefactor r178  Brian White	
    - Implemented SgConstructorInitializer.

    - Implemented SgNewExp.

    - Implemented SgThisExp.

    - Deprecated findFieldName.  Convert ROSE ast node to string
      using toStringWithoutScope instead.

    - Uncommented handling of SgConstructorInitializer in 
      FindCallsitesPass::visit.  This isn't correct, but will
      work for the majority of cases.  The problem is that
      createsBaseType, which should be called createsBasicType,
      is lame.  It assumes that any SgConstructorInitializer
      not backed by a method/constructor declaration creates
      a basic type.  We know that this also occurs when a
      constructor is not explicitly defined.

      This problem should go away once we have AST normalization
      implemented.  

      Then again, even if createsBaseType were implemented
      correctly, later code (such as getFormalTypes) would
      die since it expects a method declaration for each
      SgConstructorInitializer.

8/26/06     UseOA-Rose svn branch-memRefExprRefactor r179  Andy Stone
    - Implemented SgPntrArrRefExp

8/28/06     UseOA-Rose svn branch-memRefExprRefactor r181  Michelle Strout
    - Finished implementing MRE creation at SgFunctionCallExp.
    - Rechecked the CtoOA output for assignReturn.c

8/29/06     UseOA-Rose svn branch-memRefExprRefactor r182  Michelle Strout
    - Rechecked and generated ./CtoOA TestCases/AliasTests/retPtr1.c    
    - Implemented the va_start, va_arg, and va_end.  
      Treating va_start as if      
      it is NOT a function call.  This logic ends up in      
      findAllMemRefsAndPtrAssigns and SageOACallGraph.C:FindCallsitesPass. 
      I don't like that it is spread out like this.
      Also right now I just have it do a USEDEF on a Deref to the va_list
      parameter, but I should introduce a new MemRefExprType in OpenAnalysis
      to indicate no known ordering between the USE and the DEF.
    - use getBaseType everywhere when I get type
    - Made it so that when pass an array variable its address is taken.
      This is due to the fact that we are modeling array variables
      as one location versus a constant pointer to a separate location.
    - Array initializers such as strings should not have its address 
      taken when being used to initialize and array variable.
      Fixed that in the SgInitializedNamed node.
    - Verified these fixes on a number of test cases in AliasIRInterface.test.

8/31/06     UseOA-Rose svn branch-memRefExprRefactor r183  Brian White
    - Fixed toStringWithoutScope to properly handle SgFunctionRefExp/
      SgMemberFunctionRefExp cases.  We get the field_name by asking
      toStringWithoutScope for the string of one of these guys.

    - getLocation was returning isLocal for the 'this' ptr.
      Changed isLocal = false for this case, as per the comment
      above on 8/25.

    - Fixed getLocation so that myParent is not considered local in
      this example:

        class SubClass : public Base {
          public:
          SubClass(Base & parSubClass) : myParent(parSubClass) {}
          Base &myParent;
        };

      The problem was that the declaration stmt for myParent is
      the SgCtorInitializerList, rather than a SgVariableDeclaration
      (in the class definition).  Therefore, because the declaration
      was 'enclosing in' a function, I was calling it local.
      We know check for this SgCtorInitializerList case.

    - Changed SgInitializedName case so that it first creates and
      stores its MRE and then recurses.  A problem occurred when
      the child of a SgInitializedName was a SgConstructorInitializer,
      for which we had to get the lhs for the implicit this actual.
      i.e., this case:
	 Foo() : mF(f)
      We would attempt to make &mF the 'this' actual, where mF
      is the SgInitializedName.  Unfortunately, as this MRE
      hadn't been registered, findTopMemRefHandle was instead
      returning f.

    - Implemented SgDeleteExp:  created call handle MRE for SgDeleteExp,
      which may be a FieldAccess if the destructor is virtual.
	
    - A slew of things regarding handling of 'this'

        - SymHandle associated with the 'this' formal is _always_
          a SgFunctionParameterList.  The MRE for 'this' formal is
          NamedRef(SymHandle(SgFunctionParmaterList)).  See
          SageIRInterface::getThisExpSymHandle and getThisExpNode.

        - Created MemRefHandle/MRE for 'this' in SgExprListExp
          case whenever it would be used to model 'this'.
          i.e., when 
	     getConstructorInitializerLhs(ctorInitializer) == exprListExp
          This should occur only for invocations of a base constructor
          in the constructor initializer list.

          It may have been cleaner to create this MRE elsewhere
          (e.g., at the ctorInitializer), however I wanted to maintain
          the invariant that an MRE/MemRefHandle is created in the
          case for that MemRefHandle.  Though I violate this below ...

        - Notice that not all SgInitializedNames correspond to
          variable initializations.  e.g., in the SgInitializedName
          case I no longer create an MRE here:

	  // class Foo : public Bar { Foo(Foo &f) : Bar(f) { } }
          //
          // Bar in Bar(f) in the initializer is represented 
          // by a SgInitializedName, whose name is 'Bar'.  
          // i.e., though it appears to be so, this is not
          // a variable initialization.  Therefore, do 
          // not create an MRE for it.  Instead,
          // just visit the constructor initializer,
          // which will create the required call MRE.

        - Handle implicit this for member variable initialization
          in constructor initialization list (in SgInitializedName case)

              class Foo { Foo(Bar &b) : mBar(b) };
          
          In the above example we model mBar(b) as this->mBar = b.
          Therefore, need to conjure up a MemRefHandle for 'this'.
          
          If mBar(b) would invoke a copy constructor, then it will
          have a SgConstructorInitializer, whose args are held
          in a SgExprListExp.  In these case, we may use the
          SgExprListExp for 'this's MemRefHandle, as above.

          If mBar had a basic type, we would not have an SgExprListExp
          since the initializer would not be a SgConstructorInitializer.
          Instead we would have a SgAssignInitializer.  Since we don't
          use this for anything else, we may return it as the MemRefHandle.

        - Therefore, the following may be used as MemRefHandles for
          a 'this' expression:  SgThisExp (when present), SgExprListExp,
          or SgAssignInitializer/SgAggregateInitializer.
     
8/31/06     UseOA-Rose svn branch-memRefExprRefactor r185  Michelle Strout
    - Copied changes over from the UseOA-ROSE trunk that enable
      the memRefExprRefactor branch to compile with OpenAnalysis r220.
    - Made it so that a parameter binding is created if the formal
      parameter is an array type because we have to model those as
      pointers.
    - Verified swap.c, comma.c, passIntPtrArrayRef*.c, and some others.

9/1/06     UseOA-Rose svn branch-memRefExprRefactor r186  Michelle Strout
    - Fixed member variable inializers somewhat.  Now the ptr assignment
      is correct, but still missing an MRE.

9/5/06     UseOA-Rose svn branch-memRefExprRefactor r188  Michelle Strout
    - Fixed bug where the MemRefExpr for the field being initialized
      was not being listed.
    - Rechecked everything in FIAliasAliasMap.test.  Only found one
      problem in constQualified.c.  Need to fix that pointer
      arithmetic node.

9/06/06     UseOA-Rose svn branch-memRefExprRefactor r189  Brian White	

        - Some fixes to SgDotExp case:

            - Only create a FieldAccess for member variable accesses and
              virtual methods.  For non-virtual methods instead create
              a NamedRef.  

            - Do not erase the lhs_memref, as we need the lhs MRE
              as the receiver for a method invocation.  _Do_ 
              remove it for non-method invocations.
     
        - Changed getLocation so that 'this' is considered local.
          Remember, it is modeled as a parameter.
        
        - Was not visiting the SgExprListExp from a SgConstructorInitializer.
          Visiting the SgExprListExp is necessary because we 
          use it to model the implicit this.  Changed this.
          Since the SgExprListExp case visits its children, we 
          no longer need to explicitly visit the actuals/children of a
          SgConstructorInitializer.

        - When using the child/lhs MRE as the implicit actual of a
          SgDotExp (method invocation), we need to take its address.

        - I was seeing initMemRefAndPtrAssignMaps being invoked twice
          on the same SageIRInterface object.  Here's why.  Evidently,
          my benchmark was so simple that it did not create any
          pointer assignment pairs.

          Therefore, this check in getAliasStmtType was failing.
	
          if (mStmtToPtrPairs.empty() ) {
              initMemRefAndPtrAssignMaps();
          }

          To fix this, I have changed all guards to

          if (mStmt2allMemRefsMap.empty() ) {
              initMemRefAndPtrAssignMaps();
          }

          This may be slightly counter-intuitive in getAliasStmtType,
          for example, where a statement to mem ref map doesn't
          seem relevant.  Nevertheless, this is a consistent
          and safe guard for initMemRefAndPtrAssignMaps-- if a
          program does anything at all it will have a non-empty map.

        - Multipe, redundant MemRefHandles were showing up aggregateInit.c
          and passArrayPtr.c, evidently because of the redundant
          calls to initMemRefAndPtrAssignMaps fixed above.  Updated
          their regression results.

9/06/06     UseOA-Rose svn branch-memRefExprRefactor r191  Brian White
        - Changed SgInitializedName case so that we take the address
          of a NamedRef representing a variable declaration, if
          the declaration involves a constructor invocation since
          the variable will be passed as the implicit this actual
          (a pointer).

        - I was forgetting to add the created MRE for the SgNewExp case.

        - The SgInitializedName case of findAllMemRefsAndPtrAssigns was
          previously getting the right-hand side (of the assignment)
          MemRefHandle by visiting the initializer of the SgInitializedName.
          Unfortunately, this initializer is sometimes used to 
          generate the implicit this occuring on the lhs.  As such,
          calling getTopMemRefHandle on the initializer, to get the
          MemRefHandle for the rhs, would return the same MemRefHandle
          as used on the lhs.  So, instead we look past the initializer
          whenever we use it on the lhs.

          Michelle had previously fixed this problem by simply 
          visiting the child first, before the initializer was
          recorded as a MemRefHandle.  Unfortunately, this does not
          work because the child of the SgInitializedName might be
          a SgConstructorInitializer, for which we need to model
          an implicit this.  Such an implicit this might well be
          the SgInitializedName itself.  Therefore, we need the MRE
          for the SgInitializedName to exist before visiting the child.
	
        - Added the following tests to AliasIRInterface.test

            - paramBindgsForDotMethodInvoc

9/7/06     UseOA-Rose svn branch-memRefExprRefactor r192  Brian White	

        - Updated SgArrowExp case to reflect SgDotExp.  In particular,
          do not create FieldAccesses for non-virtual method invocations.
          Instead, just return the NamedRef for the invoked method.

        - Added the following tests to AliasIRInterface.test

            - paramBindgsForArrowMethodInvoc	

9/7/06     UseOA-Rose svn branch-memRefExprRefactor r193  Brian White

        - Fixed getFormalParamIterator so that it does not retrun
          an implicit 'this' formal for a static method.

        - Fixed SgDeleteExp case so that when it asks for the
          delete'd variables type, it recognizes that the variable
          has type SgPointerType.

        - Added SgDeleteExp call handle in FindCallsitesPass::visit.

        - Added SgDeleteExp case to toString.
	
        - Added the following tests to AliasIRInterface.test

            - paramBindgsForStaticMethodInvoc	
            - staticMemberVarAccess
            - paramBindingsForStackCtorInvoc
            - paramBindingsForDynamicCtorInvoc
            - paramBindingsForDestructorInvoc
            - implicitReceiverMethodInvoc
            - implicitReceiverDestructorInvoc
            - implicitReceiverCtorInvoc
            - implicitMemberVarAccess
            - implicitMemberVarAccessInCtorList
            - implicitMemberVarRefDefnInCtorList
            - implicitMemberVarObjDefnInCtorList
            - invokeBaseCtorInCtorList

9/7/06     UseOA-Rose svn branch-memRefExprRefactor r198  Brian White	

        - Just got regressAliasIRInterface.test synced up.  
          Revision r193 had some diffs in the regression tests.

9/7/06     UseOA-Rose svn branch-memRefExprRefactor r199  Brian White

        - Created the following tests in TestCases/AliasTests.
          These are designed to test implicit assignments arising
          from virtual method declarations.  They have not
          been tested and have not been added to regressAliasIRInterface.test.

            - dynamicInitOfClassWhoseBaseClassHasVirtualMethods.C
            - assignOfObjPtrWhoseBaseClassHasVirtualMethods.C
            - stackInitOfClassThatOverloadsBaseClassPureVirtualMethods.C
            - virtualDotBaseMethodInvocation.C
            - virtualDotOverloadedBaseMethodInvocation.C
            - stackInitOfClassWithVirtualMethods.C
            - assignOfObjPtrThatOverloadsBaseClassVirtualMethods.C
            - assignOfObjectPtrWithVirtualMethods.C
            - virtualArrowMethodInvocation.C
            - dynamicInitOfClassThatOverloadsBaseClassVirtualMethods.C
            - assignOfObjPtrThatOverloadsBaseClassPureVirtualMethods.C
            - dynamicInitOfClassWithVirtualMethods.C
            - stackInitOfClassThatOverloadsBaseClassVirtualMethods.C
            - stackInitOfClassWhoseBaseClassHasVirtualMethods.C
            - virtualArrowBaseMethodInvocation.C
            - virtualDotMethodInvocation.C
            - dynamicInitOfClassThatOverloadsBaseClassPureVirtualMethods.C
            - virtualArrowOverloadedBaseMethodInvocation.C

9/8/06     UseOA-Rose svn branch-memRefExprRefactor r200  Michelle Strout
    - Fixed MRE creation at pointer arithmetic node: SgAddOp.
      If have a pointer then need to take the address of a
      partial deref to the pointer.
    - Yanked logic for creating the implicit actual this for constructors
      out of getActuals and put it in the SgConstructorInitializer
      node in findMemRefsAndPtrAssigns code.  Now the implicit actual this
      is created there and put at SgExprListExp for SgConstructorInitializer.
      All further code assumes that.  We should do the same for
      method calls, but that has not been done yet.
    - Worked through most of the tests in AliasIRInterface.test, but
      there are still some where the results need reverified.

9/8/06     UseOA-Rose svn branch-memRefExprRefactor r201  Brian White

        - Created the following tests in TestCases/AliasTests.
          These are designed to test Peter Collingbourne's
          (along with Chunhua Liao) AST normalization in ROSE,
          checked into version ROSE-0.8.9a.  Much thanks to 
          Peter for helping me with baroque C++ syntax.

            - varInIfConditionalGoingOutOfScope.C
            - varInForInitializerGoingOutOfScope.C
            - inheritanceExample.C
            - implicitInvocationOfBaseSpecialMethods.C
            - varGoingOutOfScope.C
            - tmpGoingOutOfScope.C
            - inputDefaultFunctions.C
            - destructingAroundControlFlow.C
            - invokeUndefinedSpecialMethods.C
            - multipleInheritance.C
            - undefinedSpecialMethods.C
            - implicitInvocationOfUndefinedBaseSpecialMethods.C
            - varInForIncrGoingOutOfScope.C
            - varInReturnGoingOutOfScope.C
            - varInLoopConditionalGoingOutOfScope.C
            - inputCode_implicitCodeGenerationTest.C

9/8/06     UseOA-Rose svn branch-memRefExprRefactor r202  Brian White	

        - This version requires ROSE-0.8.9a!

        - I have added the invocation of the AST normalization to OATest.
          This could potentially be placed in the SageIRInterface
          constructor.  It seems to me that this should eventually
          be migrated to the ROSE frontend.

          I have not tested this, only compiled it.  If it gives you
          trouble, or if you are using an earlier version of ROSE,
          comment out the following from OATest.

          #include <defaultFunctionGenerator.h>
          #include <shortCircuitingTransformation.h>
          #include <destructorCallAnnotator.h>

          // Perform the AST normalization.
          DefaultFunctionGenerator dfg;
          dfg.traverse(sageProject, preorder);
          AstPostProcessing(sageProject);
          shortCircuitingTransformation(sageProject);
          destructorCallAnnotator(sageProject);
	
        - Two minor changes to make this compile with ROSE-0.8.9a.

9/8/06     UseOA-Rose svn branch-memRefExprRefactor r203  Brian White	

        - Fixed an assertion failure I created in r202.
          By default, this version uses ROSE-0.8.9a.  If you
          would like to use an earlier version, comment out
          the following in MemSage2OA.C.

          #define ROSE_0_8_9a      

        - I have removed the AST normalization above from OATest.
          I originally intended to put it in CtoOA, which we are all
          currently using.  For now, I have removed it altogether--
          it seems that we should get the regression tests working
          with the new version of ROSE before adding one more
          factor.

9/9/06     UseOA-Rose svn branch-memRefExprRefactor r204  Brian White

        - We consider function/method invocations to be uses, hence
          they need to have MREs (as well as call MREs).  This has
          already been done for methods, functions, and constructors,
          but not destructors.  Modified SgDeleteExp case to 
          create a MRE here as well.

        - Something above affected the order of Locations in the
          regression test output.  Re-created regression results
          to reflect this new ordering.

        - Suppressed warning messages by adding --edg:no_warnings -w
          flag to CtoOA.  This is important because ROSE 0.8.9a
          outputs absolute paths (in warnings) whereas our regression
          results had relative paths.  Not that re-creating the
          regression tests with absolute paths will not suffice
          because each developer would have a different absolute path.
          Re-created regression tests without warnings.

        - This version works with ROSE 0.8.7a.
	
9/10/06     UseOA-Rose svn branch-memRefExprRefactor r205  Brian White	

        - Switched to ROSE 0.8.9a.

        - Adapted findTopMemRefHandle to cope with (constant) folded
          expression, which show up in SgValueExp and SgCastExp.
          In particular, a SgCastExp now has two children-- its
          operand and the "original" expression tree, which is non-NULL
          (presumably) if the operand holds a folded value.  
          The presence of two children caused findTopMemRefHandle 
          to return 0, since there is no top in the presence of
          multiple children.  However, though there are two apparent 
          child here, there is only one actual child.  We should
          always visit the operand-- be the original, unfolded
          expression or the folded expression.

        - Fixed recognition of va_start to look for "__builtin_va_start"
          as well as "va_start".  Evidently, the former is being
          used in ROSE-0.8.9a.

        - All AliasIRInterface regression tests pass, except refClass2.
          However, to avoid an abort in parambinds-formals-intPtrs.C, you
          will need to patch ROSE-0.8.9a according to this e-mail:
          [I believe this problem actually arose in ROSE-0.8.8a]

          Date: Sun, 10 Sep 2006 15:11:13 -0400 (EDT)
          From: Brian White <bwhite@csl.cornell.edu>
          To: michelle strout <mstrout@CS.ColoState.EDU>, andy stone <aistone@gmail.com>
          Subject: null parent in va_start/va_arg & bug fix [was Re: null
                   (grand)parent bug in ROSE-0.8.8a]

9/11/06     UseOA-Rose svn branch-memRefExprRefactor r206  Brian White

        - Put common.C in namespace UseOA.  Sage2OA.C and MemSage2OA.C use
          namespace UseOA.
	
        - Some changes for handling reference conversion:

            - Don't use isSgReferenceType to determine if a type is a
              reference type in need of modeling, but rather use
              isReferenceTypeRequiringModeling.
	
            - Added mMRE2TypeMap : mre -> typeEnum that indicates
              whether an MRE has a reference or non-reference type.

              NOTE!  When you create/clone/composeWith a new MRE,
              you need to set its type.

            - Modified SgArrowExp/SgDotExp so that if rhs in a->rhs or a.rhs
              is a reference, then we deref *(a->rhs) and *(a.rhs).
              That is, we apply reference conversion rule 3. 
              Wrote referenceMemVarAccesses.C to test this.

            - Modified SgFunctionCallExp so that we dereference the
              return slot if it represents the return value of
              reference type.  This is an application of reference
              conversion rule 3.  Test:  returnReference.C.

            - Now whenever we apply reference conversion rule 3 (to deref)
              in SgVarRefExp, SgFunctionCallExp, SgArrowExp/SgDotExp,
              we also leave behind, rather than replace, the original
              expression.  Further, if we later take the address of
              this deref, effectively to recover the original
              base reference, we should remove the one that we left
              behind, lest they be redundant.  

              These base references (before the deref) have a
              Sg_File_Info MemRefHandle!  Ugly!
	
            - Changed reference conversion rule 2.  

              Previously:

              If the rhs does not have an lvalue, e.g., 3+5, &y, etc.,
              then replace lhs with *lhs.

              Please see the thread between Michelle and Brian on
              Sept 12 and 13 entitled 'formal references' for
              the deficiencies with this approach.

              Current approach (as implemented in 
              applyReferenceConversionRule2):

              For a reference initialization: 
                  t_l &lhs = rhs.             (1)
              If the rhs does not have an lval, the stmt must actually
              be of the form:  
                  t_l const &lhs = rhs;
              Model this as:
                  t_l tmpLhs = rhs;           (2a)
                  t_l const &lhs = tmpLhs;    (2b)

              Create ptr assigns for (2a) if necessary.
              Apply reference conversion rule 4 to (2b) by ignoring
              the const and noting that the rhs not has an lvalue.
              Create ptr assign for (2b).

              The tmp MREs created above use a 
              Sg_File_Info MemRefHandle!  Ugly!	
        
	    - Modified SgInitializedName to apply reference conversion
              rule 2, as well as reference conversion rule 4 (as 
              previously implemented).  If the rhs of the initialization
              has an lval, we take its address (rule 4), if it does not,
              we apply rule 2 (above).  Tests:  referenceInit.C and
              ctorReferenceInit.C, as well as the existing refClass.C
              and refClass2.C.

            - Removed the reference handling code from SgAssignOp.
              Formerly, in the case where a variable with an lval
              was assigned to a reference variable, we were removing
              the derefence to the lval and taking the address of
              the rhs.  Briefly, this is the correct behavior
              for an initialization, which affects the location of
              the reference, but not for a reference _assignment_,
              which only affects the location that the reference
              refers to.  Please see this thread:

              Date: Tue, 12 Sep 2006 20:47:10 -0600
              From: Michelle Strout <mstrout@CS.ColoState.EDU>
              To: Brian White <bwhite@csl.cornell.edu>
              Subject: Re: more reference logic

            - Modified SgReturnStmt case to apply rules 2 (if the rhs
              does not have an lval) and rule 4 (either after 2 or if
              the rhs does have an lval).  This bit looks very (too?)
              similar to the SgInitializedName case.  See the test
              returnReference.C.
        
            - Modified convertReferenceActuals so that it applies
              reference conversion rules 4 (as done previously, if the
              actual has an lvalue) and 2 (if it does not), as appropriate.

            - Merged convertReferenceActuals into 
              createParamBindPtrAssignPairs, which now applies both
              reference conversion rule 4 (as it did previously) and
              reference conversion rule 2.

            - After all of this work, what do we get?  Changed
              the regression results for refParam.C, refClass.C.

9/13/06     UseOA-Rose svn branch-memRefExprRefactor r208  Michelle Strout
    - Fixed a bug in getStmtIterator(), FindAllStmts().  We were not recursing
      down into a SgDefaultOptionStmt.

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r213  Brian White
	
            - Copied CHAandAliasVirtualMethodResolver from trunk, 
              which performs virtual call site resolution using both 
              static class hierarchy analysis (a la 
              staticVirtualMethodResolver, with which it
              should be merged) and using FIAlias.

            - Checked in Benchmarks from the paper 
              "Static Type Determination and Aliasing for C++",  
              Hemant Pande and Barbara G. Ryder, 
              Laboratory of Computer Science Research Technical Report,  
              Number LCSR-TR-250-A, October, 1995.

              Located in TestCases/AliasBenchmarks/PandeEtAl95.

              This is the complete benchmark suite from that paper, 
              including:

              chess
              city
              driv1
              driv2
              employ
              family
              fsm
              garage
              greed
              life
              np
              objects
              ocean
              office
	      primes
              shapes
              simul
              tree
              vcirc

              According to BIBLIO file, these were found at 
              http://www.cis.udel.edu/~hiper/C++benches/
              by Cornell undergrads James Juwon Lee (primarily)
              and David Drew.  In principle, they have annotated these
              with (empty) stubs-- i.e., they do not account for
              aliasing or side effects, though I expect there to be none. 

              For example, in primes.C, we see a stub section that
              begins with the comment // stubs

              // stubs

              int printf(const char *format, ...)
              {
                  return 0;
              }

              Stubs for some benchmarks may be missing, as James and David
              were unable to get all benchmarks to compile.  There are
              no makefiles, but everything should be a single file.  Where
              everything was not in a single file, they should have
              been concated into a single concat.C file.

	      James said he was unable to compile: city, employ, ocean,
              and np.

              To run, e.g., in TestCases/AliasBenchmarks/PandeEtAl95/simul:

              ../../../../CHAandAliasVirtualMethodResolver -out:results -I. simulate.C

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r214  Brian White	

          - Changed getBaseType to look through SgModifierTypes, as
            well as SgTypedefTypes.  See type-related methods in
            src/midend/astInlining/typeTraits.C.

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r216  Brian White	

          - Made virtual function table optimization the default,
            by setting default value for parameter useVtableOpt
            of SageIRInterface constructor to true.  This option
            is controlled by the member variable mUseVtableOpt.

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r217  Brian White	

          - Fixed findAllMemRefsAndMemRefExprs to visit global
            class declarations.  This was not happening because
            the method responsible for collecting global declarations,
            getGlobalObjectDeclarationsAndClassDefinitions, was
            incorrectly looking for a SgClassDefinition under SgGlobal,
            instead of a SgClassDeclaration.

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r218  Michelle Strout
    - Fixed CHAandAliasVirtualMethodResolver.C by having it call 
      ManagerFIAliasAliasMap instead of the one that generate EquivSets.
    - verified some of the AliasIRInterface.test things involving references.
      There are some diffs in there that seem new.  For example, comma.c
      now aborts.

9/14/06     UseOA-Rose svn branch-memRefExprRefactor r218  Brian White	

          - Modified creation of implicit ptr assigns for virtual
            methods in SgVariableDeclaration case.  In particular,
            we were not getting the proper lhs/object name to pass
            to createImplicitPtrAssignPairsForObjectDeclaration, so
            I explicitly created one.

          - Changed the stmt handle in the unnamed ref of a new/malloc
            to be the expression, rather than the statement.
            This choice is potentially important:  using the statement
            would limit our precision because multiple, distinct
            expressions within the same statement would be mapped to 
            the same MRE.  Further,
            createImplicitPtrAssignPairsForDynamicObjectAllocation
            assumes that the stmt handle is a SgNewExp.
	
          - Modified SgDeleteExp case to do nothing if the
            destroyed object is a basic type.

          - Modified SgConstructorInitializer to do nothing
            if the involved type is a basic type.

          - Modified SgClassDeclaration so that it does
            recurse if its definition is NULL.

          - Modified FindCallsitesPass::visit so that it
            doesn't collect a SgDeleteExp if it destroys a 
            basic type.
	
          - Modified SgReturnStmt so that it does nothing if the
            expression returned is NULL.  e.g., 
	
            void foo() { 
                if ( true ) { return; }
            }

          - In a few places where we were trying to get a class
            definition from a class declaration, first found 
            the defining class declaration.
	
	  - Passed the following tests:

              - stackInitOfClassWithVirtualMethods.C


9/14/06     UseOA-Rose svn branch-memRefExprRefactor r225  Brian White	

          - Modified SgDotExp case so that it only creates
            a FieldAccess for a virtual method if the 
            receiver is a reference, an not an object.

          - Weren't creating a deref'ed fieldaccess call
            mre for virtual methods-- changed SgDeleteExp
            and SgFunctionCallExp cases to do this.

          - Modified isVirtual to detect when it is called
            on a constructor and to return false.
            For some reason, constructors are sometimes
            annotated as virtual by ROSE.

          - When we created virtual method implicit
            assignments at a class definition (vtable approach),
            we need to always use the SgClassDefinition
            of the top-level class we are visiting
            as the virtual function table pointer base,
            as opposed to the SgClassDefinition of a
            derived class that may be defining a virtual
            method.  Changed 
            createImplicitPtrAssignPairsForClassDefinition
            to take this topClass as an argument.

          - Changed nearly all derefs to use derefMre, which
            uses composeWith.
	
	  - Passed the following tests:

              - dynamicInitOfClassWithVirtualMethods.C
              - virtualDotMethodInvocation.C
              - virtualArrowMethodInvocation.C
              - assignOfObjectPtrWithVirtualMethods.C
              - stackInitOfClassWhoseBaseClassHasVirtualMethods.C
              - dynamicInitOfClassWhoseBaseClassHasVirtualMethods.C
              - virtualDotBaseMethodInvocation.C
              - virtualDotRefBaseMethodInvocation.C
              - virtualArrowBaseMethodInvocation.C
              - assignOfObjPtrWhoseBaseClassHasVirtualMethods.C

9/15/06     UseOA-Rose svn branch-memRefExprRefactor r226  Brian White	

          - No longer generate implicit ptr assign pairs for _pure_
            virtual methods.  These can not be invoked, so including
            them would be correct, but imprecise.
	
	  - "Completed" testing of virtual methods by passing the following tests:

              - stackInitOfClassThatOverloadsBaseClassVirtualMethods.C	
              - stackInitOfClassThatOverloadsBaseClassPureVirtualMethods.C
              - dynamicInitOfClassThatOverloadsBaseClassVirtualMethods.C
              - dynamicInitOfClassThatOverloadsBaseClassPureVirtualMethods.C
              - virtualDotOverloadedBaseMethodInvocation.C
              - virtualArrowOverloadedBaseMethodInvocation.C
              - assignOfObjPtrThatOverloadsBaseClassVirtualMethods.C
              - assignOfObjPtrThatOverloadsBaseClassPureVirtualMethods.C

9/15/06     UseOA-Rose svn branch-memRefExprRefactor r227  Brian White	

          - This is the version I used for the CGO submission.  Though
            I did not run with the following change:

          - Modified above re: handling of pure virtual methods.  
            I have seen pure virtual methods with definitions!?
            Therefore, do not create implicit ptr assigns if the
            method is pure virtual _and_ does not have a definition.

9/17/06     UseOA-Rose svn branch-memRefExprRefactor r228  Brian White

          - This is the version I used for the resubmission to CGO
            on 9/16 after the 1-day extension.  

9/25/06     UseOA-Rose svn branch-memRefExprRefactor r229  Brian White	

          - Need to create implicit this actual for case in which 
            a copy constructor is invoked to copy an actual object
            parameter.  This affected createConstructorInitializerReceiverMRE.
            I created an UnnamedRef whose statement is the
            SgConstructorInitializer in case.
        
          - Implemented SgTryStmt and SgCatchStatementSeq for both
            SageIRStmtIterator::FindAllStmts and findAllMemRefsAndMemRefExprs.
 
          - Turned off AST normalization again in CtoOA.

10/02/06     UseOA-Rose svn branch-memRefExprRefactor r230  Brian White

          - Changed SgArrowExp/SgDotExp case, which was calling isArrowExp
            (i.e., -> or *.) in places where it should have been invoking 
            isSgArrowExp (i.e., -> only).  Note:  still invoking isArrowExp
            to determine whether the invocation may be virtual (. can not
            be).

          - All regression tests pass.  However, I noticed that strange
            MemRefExprs like struct __gconv_loaded_object are appearing.
            These seem to appear regardless of whether we visit header
            files.  Unfortunately, they are probably platform dependent,
            so that regression tests may be different on different
            platforms.

10/02/06     UseOA-Rose svn branch-memRefExprRefactor r231  Brian White

          - Need to create implicit this actual for case in which 
            a copy constructor is invoked to copy an object in a return
            expression.  This affected createConstructorInitializerReceiverMRE.
            I created an UnnamedRef whose statement is the
            SgConstructorInitializer in case.	

          - Moved flag excludeInputFiles from an optional param to
            SageIRProcIterator constructor to an optional param of
            SageIRInterface constructor.  Now, we use this consistently.
            Previously, whenever SageIRInterface created a SageIRProcIterator
            it was passing excludeInputFiles = false to SageIRProcIterator.
            However, another part of our analysis, external to SageIRInterface,
            might have directly created a SageIRProcIterator with
            excludeInputFiles = true.  This might have lead to 
            inconsistencies.

          - For each alias analysis benchmark in 
            AliasTests/AliasBenchmarks/PandeEtAl95, created a file
            singleFile.C which should be used for analysis.  This file
            is a concatentation of not only all of the .C files (as was
            put in concat.C), but also of all of the user header files.
            Therefore, we can analyze these files without visiting
            any header files (i.e., excludeInputFiles = true), 
            which should be more efficient.

10/09/06     UseOA-Rose svn branch-memRefExprRefactor r232  Brian White

          - Was not properly visiting SgTryStmt and SgCatchStatementSeq,
            because I had them under the SgScopeStatement clause of
            SageIRStmtIterator::FindAllStmts rather than the SgStatement
            clause.

          - Invocation of qualified methods (i.e., Parent::methodName)
            may be statically resolved and should not be marked as
            virtual.  Such SgMemberFunctionRefExp have
            get_need_qualifier() == true.

          - Modified CHAandAliasVirtualMethodResolver.C to account
            for the above-mentioned qualified method names, which
            are statically resolvable (not virtual).

          - CHAandAliasVirtualMethodResolver.C was recursing down the
            class hierarchy, invoked getSubClasses on each class.
            This is both unecessary and incorrect since getSubClasses(cls)
            returns all subclasses (direct and indirect) of cls.

          - Finished checking reference regression tests, by
            verifying output for
              - referenceInit.C
              - referenceFormal.C
              - returnReference.C
              - refCall.C	

10/09/06     UseOA-Rose svn branch-memRefExprRefactor r233  Brian White
          - Added getSgNode : ProcHandle -> SgFunctionDefinition.
            We should be creating such methods as we go along.  This allows
            us to relate OA analysis results back to Sage/ROSE.

          - Changed CHAandAliasVirtualMethodResolver so that it only
            reports results for invoked functions.  Reporting results
            for all functions/methods was causing a minor headache.  
            Imagine that we have:

                void foo(bar *b) { b->callMethod(); }

            If foo is never called in the program, then b will never
            be bound (via any param bindings occuring at a callsite).
            Therefore, b->callMethod() would give us an invisible 
            location (for alias analysis-based results).  For CHA
            would we get some valid result.  Two problems here:
            we were getting invisible location, which seemed wrong;
            how do we compare 0 resolutions for alias analysis vs
            whatever CHA was giving us.

            Now, we should never get invisible locations.  I believe.
            If we do, this is an error.

            Implementation:  use a worklist to output results only
            for invoked functions/methods.  Initialize the worklist
            to hold only main.  Then for each function in the worklist,
            append any function invocations within that function to
            the worklist.

            XXX:  There is a lot of redundancy in the CHA code.
                  This should be merged.

            XXX:  I am using a vector for the worklist.  Should
                  have used a queue.

        - Checked CHAandAliasVirtualMethodResolver results for family.
          Henceforth, I will put results for a benchmark 'bmk' in
          TestCases/AliasBenchmarks/PandeEtAl95/bmk/cha.{results, out}
          generated within dir: TestCases/AliasBenchmarks/PandeEtAl95/bmk via
          
	  rm cha.results ; ../../../../CHAandAliasVirtualMethodResolver -out:cha.results family.C > & cha.out  		

10/10/06     UseOA-Rose svn branch-memRefExprRefactor r234  Brian White

        - In CHAandAliasVirtualMethodResolver I was forgetting to add
          non-virtual methods/functions to the worklist.

        - Verified results for the following Pande benchmarks:
            - vcirc
            - garage
            - tree
            - objects
            - ocean

        - "Discussion" of fine-grained differences.  Fewer resolutions are
          better/more precise (assuming correctness, which has been manually
          verified).

            - vcirc:   FIAlias 4 resolutions vs CHA 6

                       CHA believes that the virtual methods Hide and Show
                       in

                           void Point::MoveTo(int NewX, int NewY) {
                             Hide();         // make current point invisible
                             X = NewX;       // change X and Y coordinates to new location
                             Y = NewY;
                             Show();         // show point at new location
                           }

                       may be invoked on either Point or its subclass Circle.
                       FIAlias knows that the implicit this actual of Point::MoveTo
                       is never bound to a Circle; therefore only 1 resolution
                       is possible for each of Hide and Show.

                       Because of this, FIAlias recognizes 4 monomorphic sites
                       as opposed to 2 for CHA.

                       RTA would return the same results as FIAlias, since
                       a Point is never allocated in the program.  However,
                       we could instantiate a Point object; FIAlias would still
                       do the proper thing, but RTA would not.  Actually,
	               I don't think this is true:  if we allocate a Point
                       than through the common Point constructor, its 'this'
                       will be aliased with the 'this' of a Circle.
                       Therefore, this->Hide() above will resolve to both
                       Circle::Hide and Point::Hide.  Yes; I have just verified
                       this.  SIGNIFICANTLY:  this is a shortcoming of 
                       FIAlias (namely the symmetric nature of assignment),
                       rather than our approach-- i.e., no precision is
                       lost by our modeling.

            - garage:  FIAlias 2 vs CHA 3.

                       FIAlias (correctly) believes that

                           parked[bay]->identify()

                       resolves to Car::identify and Truck::identify, while
                       CHA also thinks that Vehicle::identify is possible, since
                       Vehicle * is the static type of parked[bay].

                       As above, no Vehicle is instantiated.  Therefore, RTA
                       would again give us the correct results.  And, as 
                       argued above, were we to instantiate a Vehicle object,
                       FIAlias would return imprecise results because of
                       param binding at the (base) constructor, which leads to
                       aliasing of a Car, Truck, and Vehicle.  Again,
                       a failing of FIAlias, not our approach.               

            - tree:  FIAlias 3 vs CHA 4

                     Just like the above 2 cases.  The base class, Node, of
                     3 other classes-- UnaryNode, BinaryNode, and RealNode,
                     is never instantiated.  Therefore, FIAlias correctly
                     determines that 

                        nodePtr->nodeValue()

                     invoked from Tree::value() can never invoke a Node.
                     Same caveats as above wrt RTA and imprecision due
                     to FIAlias, rather than modeling.

            - objects:  FIAlias 13 vs CHA 11

                        There are differences in two call sites:  the invocation
                        of Type in main and of Get from SpArray::Fetch.

                        Invocaton of a3->Type() in main.

                        Precise result:  only A::Type may be invoked.

                        CHA result:  A::Type and B::Type may be invoked.  This
                        occurs because the static type of a3 is A and B is a 
                        subclass of A.  Since no B's are allocated, RTA
                        would have determined the precise result.

                        FIAlias result:  A::Type, Array::Type, and SpArray::Type
                        may be invoked.  The problem is that A, Array, and SpArray
                        share a common base class, Object.  As described above,
                        a3 is aliased through its constructor implicit arg.

                        Specifically:

                            // invokes Object ctor and binds a1 (as implicit this
                            // actual to Object::this).
                            A *a1 = new A(1);   
                            // invokes Object ctor and binds a2 (as implicit this
                            // actual to Object::this).	 Implies a1 and a2 bound.
                            A *a2 = new A(2);   
                            A *a3;
                            // invokes Object ctor and binds ar (as implicit this
                            // actual to Object::this).	 Implies a1, a2, ar bound.
                            Array *ar = new Array(3,VOLAT);
                            // invokes Object ctor and binds sar (as implicit this
                            // actual to Object::this).	 Implies a1, a2, ar, sar bound.	
                            SpArray *sar = new SpArray(3,VOLAT);

                            Array *a;
                            if (0)
                                a = ar;
                            else
                                a = sar;
                            a->Assign(a1);
                            a->Assign(a2, 2);
                            // Because of the two above Assigns, Fetch may
                            // return a1 or a2.  Therefore, we expect a3 to
                            // be a1 or a2.  Unfortunately, a1 and a2 are
                            // bound above to ar and sar.  Therefore,
                            // we have the alias set {a1, a2, a3, ar, sar}.
                            a3 = (A *)a->Fetch(2);
                            // Therefore, a3->Type() may invoke A::Type,
                            // Array::Type, or SpArray::Type.
                            a3->Type();

                        Invocaton of Get() in SpArray::Fetch.

                        CHA result:  SpArray::Get only possible invocation,
                        since it only looks in SpArray and its subclasses.
                        Array::Get is defined, but Array is a _super_class of SpArray.

                        FIAlias result:  Array::Get or SpArray::Get.  Just
                        as above, binding occurs through implicit this actual.
                        Therefore, we get every class that defines Get.

            - ocean:  FIAlias 6 vs CHA 5	

                      Difference is at the invocation of reproduce within
                      Prey::MoveTo.  reproduce is implemented by Cell, Predator, and
                      Prey, where inheritance dag (base -> child): 
                      Cell -> Prey -> Predator.

                      CHA result:  since reproduce is invoked from Prey::MoveTo,
                      CHA only looks for reproduce in Prey and Predator (i.e, the 
                      class defining the caller and any of its subclasses), not in the
                      base class Cell.

                      FIAlias result:  as usual, since Cell is a shared base class
                      of Prey and Predator, wherever we believe we have a Prey or
                      Predator, we also think we may have a Cell.  Same caveats/issues
                      as above.  Failing of FIAlias, not our approach.

                      Note that the other call site cells[row][col]->process();
                      in Ocean::run, is truly polymorphic and definitely can
                      invoke all three of Cell::process, Prey::process, and
                      Predator::process.  cells[row][col] is populated with
                      objects of each of these types in Ocean::initCells, 
                      via invocations of addEmptyCells(), addPrey(), and addPredators(),
                      respectively.  i.e., the precision result for this
                      call site has 3 resolutions.


10/10/06     UseOA-Rose svn branch-memRefExprRefactor r235  Brian White

        - Changed matchingFunctions (a predicate returning true if
          two functions have the same type signature) to call getBaseType
          before comparing types.  The driv1 benchmark defines a
          pure virtual method with a char * arg, while implementations of
          that virtual method use a typedef to a char *.  Before
          calling getBaseType, UseOA thought these were different methods.

        - Also need to change mangleFunctionName to invoke getBaseType
          on types.  Otherwise, the field access (mangled name) above to 
          the pure virtual method would not match any of the derived
          methods, which use the typedef for their args.
	
        - Implemented SgForInitStatement case in findAllMemRefsAndMemRefExprs.
          Remarkably, this hadn't been done!
	
        - CHAandAliasVirtualMethodResolver was not visiting destructors
          or constructors.  Fixed that.

        - According to Stroustrup 2nd edition section r.12.7, 
          invocations of virtual methods within destructors or
          constructors may be statically resolved.  Therefore,
          do not create FieldAccesses for them.

        - Fixed CHAandAliasVirtualMethodResolver so that it does
          not consider any methods invoked from a constructor
          or destructor to be virtual.

        - Added indirectcalltrace.C to repository.  This is implemented
          within the PIN framework (rogue.colorado.edu/pin/) for
          instrumentation.  Specifically, I implemented this using
          pin-2.0.  I have included the makefile, which was in 
          the SimpleExamples subdirectory.  indirectcalltrace can not
          be built here, as it requires pin.  I am adding it
          because I almost lost it.

          It is invoked on a _binary_.  e.g.,

          ~/pin-2.0-3077-gcc.3.2-ia32-linux/Bin/pin -t ~/pin-2.0-3077-gcc.3.2-ia32-linux/SimpleExamples/indirectcalltrace -- ./singleFileSansStubs > pin.out

          By default, it writes to the output file indirectcalltrace.out.  
          This output file contains an entry for dynamic indirect call.
          Therefore, it provides the most precise virtual method
          resolution that an alias analysis could hope to achieve.

          For each of the benchmarks, I am providing a singleFileSansStubs.C
          file, which is singleFile.C, without the stubs.  Removing
          the stubs is necessary for compilation.  Now, just compile
          and link singleFileSansStubs.C to create a binary, using
          your favorite backend compiler.  Then, run it through
          pin/indirectcalltrace, as shown above.

          The names in the output file are mangled, so you will probably
          want to run through c++filt:

          more indirectcalltrace.out | grep Resolution | c++filt | sort -u | more	

        - For each benchmark, we should have the following files:
              singleFile.C           // includes all user-defined headers and
                                     // source files and intended for analysis
                                     // i.e., has stubs.
              singleFileSansStubs.C  // singleFile.C, but without stubs.
                                     // rather than being intended for
                                     // analysis, is intended to be built
                                     // and run through pin/indirectcalltrace.
              cha.results            // CHA and FIAlias analysis results
                                     // collected from 
                                     // CHAandAliasVirtualMethodResolver
              cha.out                // output spewed from
                                     // CHAandAliasVirtualMethodResolver
              pin.results            // Dynamic resolutions from
                                     // indirectcalltrace-- i.e.,
                                     // the output that is put in 
                                     // indirectcalltrace.out by default.
              README                 // discusses and compares results
                                     // from CHA, FIAlias, and pin.
          I will no longer be putting discussion of results in this
          ChangeLog; those will instead go in the per-benchmark READMEs.
	
        - Verified results for the following Pande benchmarks:
            - chess
            - simul
            - shapes


        - "Discussion" of fine-grained differences.  Fewer resolutions are
          better/more precise (assuming correctness, which has been manually
          verified).

            - chess:   FIAlias 6 resolutions vs CHA 6 (precise: 6)

                       These are the most precise results possible.
                       There is only 1 virtual call site and it is 
                       6-way polymorphic.  The call is

                           config[i][j]->Rep ()

                       from Board::Dump.  Rep() is implemented
                       by each of the 6 pieces of the chess board.
                       It is also implemented as a pure virtual
                       method in Piece, but we do not consider
                       pure virtual methods as potential resolutions
                       (since they can not be invoked).

                       We see from the constructor Board::Board
                       that this call is truly 6-way polymorphic.
                       There we see that config[i][j] is set to
                       each of the 6 type of pieces (for some i,j).

            - simul:   FIAlias 6 resolutions vs CHA 9 (precise: 6)

                       Class hierarchy (base -> child):
                       simulation_unit -> pop_around
                       simulation_unit -> crawl_around

                       There are 3 virtual invocations:
                           display from simulation_unit::move
                           erase   from simulation_unit::move
                           cycle   from main

                       Note that display is invoked from each of the
                       3 constructors, but although display is
                       virtual, it may only be resolved within the
                       current class or one of its base classes _NOT_
                       within a subclass.  See section r.12.7 of
                       Stroustrup Edition 2-- '... virtual functions
                       may be called (directly or indirectly) [in a
                       constructor or destructor].  The function called
                       will be the one defined in the constructor's 
                       (or destructor's) own class or its bases, but _not_
                       any function overriding it in a derived class.
                       This ensures that unconstructed objects will not
                       be accessed during construction or destruction.'

                       In each of the above 3 cases, simulation_unit,
                       pop_around, and crawl_around define the virtual
                       method.

                       CHA result:  because the static type of the
                       receiver is simulation_unit for each of the 3
                       invocations, it infers that the type of 
                       the receiver is simulation_unit or either of
                       its two subclasses.

                       FIAlias result:  since no simulation_unit
                       object is created, no varible is assigned its
                       virtual ptr table.  Therefore, none of the
                       simulation_unit virtual methods will be 
                       invoked.  RTA would also give the precise
                       results (assuming that RTA does not consider
                       an object of a class base to be instantiated during
                       the creation of an object of its subclass).

10/20/06     UseOA-ROSE svn trunk r239   Michelle Strout
	Merging the memRefExprRefactor branch into the trunk.
	svn merge -r 143:238
	svn+ssh://svn.berlios.de/svnroot/repos/useoa-rose/branch/memRefExprRefactor

	regressAll with OA r246 has the following problems
    -There is some different header output on okapi than on Brian's machine,
     gnu_dev_major, struct __sched_param, etc.  For now ignore those.
    - In AliasIRInterface.test there are some tests that output debug
      information that they shouldn't.
        Eg. [In unparseType
    - Some core dumping in the ParamBindings.
    - Some core dumping in the ICFG.
      ICFG needs completely rechecked.
    - SideEffects need rechecked.
    - ReachDefs need rechecked.

10/26/06     UseOA-ROSE svn trunk r240   Priyadarshini Malusare
    - Added following in Sage2OA.h::toString(StmtHandle h)  
      SgExpression * sgExp= isSgExpression(node);
      if( sgExp ) {
         return sgExp->unparseToString();
      }
    - ICFG tests are checked and regenerated for the new modification.

10/29/06     UseOA-ROSE svn trunk r241   Priyadarshini Malusare
    - Modified ManagerReachDefsStandard::transfer, killed definitions 
      are properly removed from the inRecast set.

11/01/06     UseOA-ROSE svn trunk r242   Priyadarshini Malusare
    - Added SageIRInterface::getConstValBasic(OA::ConstValHandle c)
      to get ReachConsts working on UseOA-ROSE side.
    - passes regressAll with OpenAnalysis trunk r247 compiled on Okapi
      with gcc-3.2.

11/01/06     UseOA-ROSE svn trunk r243   Priyadarshini Malusare
    - Added test script, genReachConsts script, regressReachConsts script
    - Added TestCases and TestResults for ReachConsts.
    - passes regressAll with OpenAnalysis trunk r247 compiled on Okapi
      with gcc-3.2.

11/02/06     UseOA-ROSE svn trunk r244   Priyadarshini Malusare
     - SageIntegerConstVal::eval()
     - Added test script, genICFGReachConsts script, 
       regressICFGReachConsts script
     - Added TestCases and TestResults for ICFGReachConsts.
     - passes regressAll with OpenAnalysis trunk r247 compiled on okapi
       with gcc-3.2.

11/07/06     UseOA-ROSE svn trunk r245   Luis Ramos
    - Regenerated ParamBindings and SideEffect in order to represent the
      changes done on ExprTree in OA

